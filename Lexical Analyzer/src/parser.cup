import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;

parser code {: 
    private Lexer scanner;
    private HashMap<String, ArrayList<String>> listaTablasSimbolos;
    private String currentHash;

    public Parser(Lexer scanner) {
        this.scanner = scanner;
        this.listaTablasSimbolos = new HashMap<>();
        this.currentHash = "";
    }

    public void setSymbolTable(HashMap<String, ArrayList<String>> tablaSimbolos) {
        this.listaTablasSimbolos = tablaSimbolos;
    }

    private void agregarSimbolo(String tipoTabla, String identificador, String tipo) {
        ArrayList<String> nuevaEntrada = new ArrayList<>();
        nuevaEntrada.add("tipo:" + tipoTabla);
        nuevaEntrada.add("identificador:" + identificador);
        nuevaEntrada.add("tipo_dato:" + tipo);

        currentHash = identificador;
        listaTablasSimbolos.put(currentHash, nuevaEntrada);
    }

    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("Tabla de simbolo: " + key);
            System.out.println("Valores: ");
            for (String item : listaTablasSimbolos.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }
    }

:};

//init with {: scanner.init(); :};

scan with {: return scanner.next_token(); :};

//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;

//bloques de código
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;

//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;

//asignacion =
terminal ASIGNACION;

//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 

//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;

//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;

//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;

//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;

//funciones de leer
terminal PRINT, READ;

//identificadores
terminal IDENTIFICADOR;

//final de expresion y Main
terminal END_EXPR, MAIN;

non terminal tipo, literal, op_aritmeticas, dato_general, expr, sec_oper, sec_var, imprimir, leer_var, inicializacion, 
actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion_operacion, op_logica, expr_logica_aritmetica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, encabezado, funciones, funcion, programa, llamada_funcion, parametros_llamada;

//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

start with programa;

//Reglas
nombrefuncion ::= MAIN 
                 | IDENTIFICADOR:idVar {: System.out.println("Identificador de función: " + idVar); RESULT = idVar.toString(); agregarSimbolo("funcion", idVar.toString(), "N/A"); :};

parametro_decl ::= tipo:tipo IDENTIFICADOR:idVar COMMA parametro_decl {: System.out.println("Parámetro: " + idVar); RESULT = idVar.toString(); agregarSimbolo("parametro", idVar.toString(), tipo.toString()); :} 
                  | tipo:tipo IDENTIFICADOR:idVar {: System.out.println("Parámetro: " + idVar); RESULT = idVar.toString(); agregarSimbolo("parametro", idVar.toString(), tipo.toString()); :};

parametros_decl ::= parametro_decl | ;

sec_oper ::= dato_general COMMA sec_oper | dato_general;

parametros_llamada ::= sec_oper | ;

llamada_funcion ::= nombrefuncion PARENTESIS_APERTURA parametros_llamada PARENTESIS_CIERRE;

tipo ::= INTEGER {: System.out.println("TIPO: int"); RESULT = "int"; :}
        | FLOAT {: System.out.println("TIPO: float"); RESULT = "float"; :}
        | BOOL {: System.out.println("TIPO: bool"); RESULT = "bool"; :}
        | CHAR {: System.out.println("TIPO: char"); RESULT = "char"; :}
        | STRING {: System.out.println("TIPO: string"); RESULT = "string"; :};

literal ::= INT_LITERAL:intVar {: System.out.println("Literal entero: " + intVar); RESULT = intVar.toString(); :}
          | STRING_LITERAL:strVar {: System.out.println("Literal string: " + strVar); RESULT = strVar.toString(); :}
          | FLOAT_LITERAL:floatVar {: System.out.println("Literal float: " + floatVar); RESULT = floatVar.toString(); :}
          | CHAR_LITERAL:charVar {: System.out.println("Literal char: " + charVar); RESULT = charVar.toString(); :}
          | BOOL_LITERAL:boolVar {: System.out.println("Literal booleano: " + boolVar); RESULT = boolVar.toString(); :};

expr ::= expr:e1 SUMA expr:e2 {: System.out.println("Expresión suma: " + e1 + " + " + e2); RESULT = e1 + " + " + e2; :}
       | expr:e1 RESTA expr:e2 {: System.out.println("Expresión resta: " + e1 + " - " + e2); RESULT = e1 + " - " + e2; :}
       | expr:e1 MULTIPLICACION expr:e2 {: System.out.println("Expresión multiplicación: " + e1 + " * " + e2); RESULT = e1 + " * " + e2; :}
       | expr:e1 DIVISION expr:e2 {: System.out.println("Expresión división: " + e1 + " / " + e2); RESULT = e1 + " / " + e2; :}
       | expr:e1 MODULO expr:e2 {: System.out.println("Expresión módulo: " + e1 + " % " + e2); RESULT = e1 + " % " + e2; :}
       | expr:e1 POTENCIA expr:e2 {: System.out.println("Expresión potencia: " + e1 + " ^ " + e2); RESULT = e1 + " ^ " + e2; :}
       | PARENTESIS_APERTURA expr:e PARENTESIS_CIERRE {: System.out.println("Expresión entre paréntesis: " + e); RESULT = "(" + e + ")"; :}
       | IDENTIFICADOR:idVar {: System.out.println("Identificador en expresión: " + idVar); RESULT = idVar.toString(); :}
       | literal;

op_aritmeticas ::= SUMA | RESTA | MULTIPLICACION | DIVISION | MODULO | POTENCIA;

dato_general ::= IDENTIFICADOR:idVar {: System.out.println("Variable: " + idVar); RESULT = idVar.toString(); agregarSimbolo("variable", idVar.toString(), "N/A"); :} | literal | llamada_funcion;

op_unaria ::= IDENTIFICADOR:idVar INCREMENTO {: System.out.println("Incremento: " + idVar); RESULT = idVar.toString() + "++"; agregarSimbolo("operacion", idVar.toString(), "incremento"); :} 
              | IDENTIFICADOR:idVar DECREMENTO {: System.out.println("Decremento: " + idVar); RESULT = idVar.toString() + "--"; agregarSimbolo("operacion", idVar.toString(), "decremento"); :};

sec_var ::= IDENTIFICADOR:idVar COMMA sec_var {: System.out.println("Variable en lista: " + idVar); RESULT = idVar.toString(); agregarSimbolo("variable", idVar.toString(), "N/A"); :} 
             | IDENTIFICADOR:idVar {: System.out.println("Variable en lista: " + idVar); RESULT = idVar.toString(); agregarSimbolo("variable", idVar.toString(), "N/A"); :};

imprimir ::= PRINT PARENTESIS_APERTURA sec_oper PARENTESIS_CIERRE; 
leer_var ::= READ PARENTESIS_APERTURA sec_var PARENTESIS_CIERRE; 

actualizacion ::= ASIGNACION | op_aritmeticas ASIGNACION;
asignacion_arreglo ::= IDENTIFICADOR:idVar ASIGNACION APERTURA_DE_BLOQUE sec_oper CIERRE_DE_BLOQUE {: System.out.println("Asignación arreglo: " + idVar); RESULT = idVar.toString(); :};
asignacion_indice ::= IDENTIFICADOR:idVar CORCHETE_APERTURA dato_general CORCHETE_CIERRE actualizacion expr_logica_aritmetica {: System.out.println("Asignación índice: " + idVar); RESULT = idVar.toString(); :};
asignacion_variable ::= IDENTIFICADOR:idVar actualizacion expr_logica_aritmetica {: System.out.println("Asignación variable: " + idVar); RESULT = idVar.toString(); :};
asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;

declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE sec_oper CIERRE_DE_BLOQUE | ; 
declaracion ::= tipo:tipo IDENTIFICADOR:idVar {: System.out.println("Declaración: " + idVar); RESULT = idVar.toString(); agregarSimbolo("declaracion", idVar.toString(), tipo.toString()); :}
              | tipo:tipo IDENTIFICADOR:idVar ASIGNACION expr_logica_aritmetica {: System.out.println("Declaración con asignación: " + idVar); RESULT = idVar.toString(); agregarSimbolo("declaracion", idVar.toString(), tipo.toString()); :}
              | tipo:tipo IDENTIFICADOR:idVar CORCHETE_APERTURA dato_general CORCHETE_CIERRE declaracion_arreglo_op {: System.out.println("Declaración arreglo: " + idVar); RESULT = idVar.toString(); :};

else_expr ::= ELSE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE;
else_op ::= else_expr | ;

relacion ::= MENOR | MENOR_IGUAL | MAYOR | MAYOR_IGUAL | IGUALDAD | DIFERENTE;
comparacion_operacion ::= expr_logica_aritmetica relacion expr_logica_aritmetica | expr_logica_aritmetica op_aritmeticas expr_logica_aritmetica | dato_general | op_unaria; 
op_logica ::= CONJUNCION | DISYUNCION;
expr_logica_aritmetica ::= NEGACION expr_logica_aritmetica | expr_logica_aritmetica op_logica expr_logica_aritmetica | comparacion_operacion | PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE;
if_expr ::= IF PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE else_op;

cases ::= CASE literal DOS_PUNTOS bloques cases | DEFAULT DOS_PUNTOS bloques;
switch_expr ::= SWITCH PARENTESIS_APERTURA dato_general PARENTESIS_CIERRE APERTURA_DE_BLOQUE cases CIERRE_DE_BLOQUE;

finfuncion ::= RETURN dato_general | RETURN;
op_simple ::= op_unaria | asignacion_variable; 
simple_expr ::= op_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | llamada_funcion | finfuncion;
while_expr ::= WHILE PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE;
inicializacion ::= asignacion_variable | IDENTIFICADOR:idVar {: RESULT = idVar.toString(); :};
for_expr ::= FOR PARENTESIS_APERTURA inicializacion COMMA expr_logica_aritmetica COMMA op_simple PARENTESIS_CIERRE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE;

bloque ::= if_expr | while_expr | for_expr | simple_expr END_EXPR | switch_expr; 
bloques ::= bloque bloques | ; 
encabezado ::= nombrefuncion PARENTESIS_APERTURA parametros_decl PARENTESIS_CIERRE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE;

funciones ::= funcion | funcion funciones;
funcion ::= tipo encabezado;

programa ::= funciones;
