//import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java_cup.runtime.Symbol;


parser code {: 
    private Lexer scanner;
    private HashMap<String, ArrayList<String>> listaTablasSimbolos;
    private String currentHash;
    private BufferedWriter outputFile;



    public Parser(Lexer scanner) {
        this.scanner = scanner;
        this.listaTablasSimbolos = new HashMap<>();
        this.currentHash = "";
    }



    public void setSymbolTable(HashMap<String, ArrayList<String>> tablaSimbolos) {
        this.listaTablasSimbolos = tablaSimbolos;
    }



    private void agregarSimbolo(String symbol) {
        //if (!listaTablasSimbolos.get(currentHash).contains(symbol)) {
            listaTablasSimbolos.get(currentHash).add(symbol);
        //}
    }



    public void imprimirTablaSimbolos() {
        System.out.println("----------------------------------------------------------------------------------------------");
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("Ambito: " + key);
            System.out.println("Simbolos: ");
            for (String item : listaTablasSimbolos.get(key)) {
                System.out.println("    " + item);
            }
            System.out.println("");
        }
    }


        public void createWriter(String root) throws IOException {
        outputFile = new BufferedWriter(new FileWriter(root));
    }


    public void reportSyntaxError(int line, int column) throws IOException {
        if(outputFile != null) {
            outputFile.write("Error sintáctico recuperado en línea " + line + ", columna " + column + ".\n");
            outputFile.flush();
        }
    }

    public void closeWriter() throws IOException {
        if(outputFile != null) {
            outputFile.close();
        }
    }


    @Override
    public void syntax_error(Symbol current) {
        try {
          reportSyntaxError(current.left, current.right);
          //System.out.println("Error sintáctico, línea: " + current.left + ", columna: " + current.right);
        } catch (IOException e) {
          e.printStackTrace();
        }
    }

:};

//init with {: scanner.init(); :};

scan with {: return scanner.next_token(); :};

//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;

//bloques de código
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;

//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;

//asignacion =
terminal ASIGNACION;

//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 

//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;

//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;

//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;

//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;

//funciones de leer
terminal PRINT, READ;

//identificadores
terminal IDENTIFICADOR;

//final de expresion y Main
terminal END_EXPR, MAIN;

non terminal tipo, literal, op_aritmeticas, dato_general, sec_oper, sec_var, imprimir, leer_var, inicializacion, 
actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion_operacion, op_logica, expr_logica_aritmetica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, funciones, funcion, programa, llamada_funcion, parametros_llamada, expr_unaria;


//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;
precedence right INCREMENTO, DECREMENTO;

start with programa;




//Reglas
nombrefuncion ::= MAIN {: 
                    RESULT = "_main_";
                    currentHash = "_main_"; 
                    System.out.println("Ambito cambiado a: main"); 
                    listaTablasSimbolos.putIfAbsent(currentHash, new ArrayList<>());
                    :}
                 | IDENTIFICADOR:nombreFunc {: 
                    RESULT = nombreFunc;
                    currentHash = nombreFunc.toString(); 
                    System.out.println("Ambito cambiado a: " + nombreFunc);
                    listaTablasSimbolos.putIfAbsent(currentHash, new ArrayList<>());
                :};





parametro_decl ::= tipo:t IDENTIFICADOR:idVar COMMA parametro_decl:param {: System.out.println("Parámetro: " + idVar); agregarSimbolo(t.toString() + ":" + idVar.toString()); RESULT = t + ":" + idVar + ":" + param; :}
                  | tipo:t IDENTIFICADOR:idVar {: System.out.println("Parámetro: " + idVar); agregarSimbolo(t.toString() + ":" + idVar.toString()); RESULT = t + ":" + idVar; :};




parametros_decl ::= parametro_decl:params {: RESULT = params; :} | {: RESULT = ""; :};



sec_oper ::= dato_general:dato COMMA sec_oper:seq {: RESULT = dato + ":" + seq; :} | dato_general:dato {: RESULT = dato; :};



parametros_llamada ::= sec_oper:seq {: RESULT = seq; :} | {: RESULT = ""; :} ;





llamada_funcion ::= nombrefuncion:f PARENTESIS_APERTURA parametros_llamada:params PARENTESIS_CIERRE 
{:
    System.out.println("Llamada a función: " + f.toString() + ", argumentos: " + params.toString());
    RESULT = f + ":" + params.toString();
    agregarSimbolo(f + ":" + params.toString());
:};





tipo ::= INTEGER {: System.out.println("TIPO: int"); RESULT = "int"; :}
        | FLOAT {: System.out.println("TIPO: float"); RESULT = "float"; :}
        | BOOL {: System.out.println("TIPO: bool"); RESULT = "bool"; :}
        | CHAR {: System.out.println("TIPO: char"); RESULT = "char"; :}
        | STRING {: System.out.println("TIPO: string"); RESULT = "string"; :};



literal ::= INT_LITERAL:intVar {: RESULT = intVar.toString(); :}
          | STRING_LITERAL:strVar {: RESULT = strVar.toString(); :}
          | FLOAT_LITERAL:floatVar {: RESULT = floatVar.toString(); :}
          | CHAR_LITERAL:charVar {:  RESULT = charVar.toString(); :}
          | BOOL_LITERAL:boolVar {:  RESULT = boolVar.toString(); :};





op_aritmeticas ::= SUMA {: System.out.println("Operador: suma"); RESULT = "+"; :} | RESTA {: System.out.println("Operador: resta"); RESULT = "-"; :} | MULTIPLICACION {: System.out.println("Operador: multiplicación"); RESULT = "*"; :} | DIVISION {: System.out.println("Operador: división"); RESULT = "/"; :} | MODULO {: System.out.println("Operador: módulo"); RESULT = "%"; :} | POTENCIA {: System.out.println("Operador: potencia"); RESULT = "^"; :};



dato_general ::= IDENTIFICADOR:idVar {: System.out.println("Variable: " + idVar); RESULT = idVar.toString(); :} | literal:lit {: RESULT = lit.toString(); :} | llamada_funcion:func {: RESULT = func; :};



op_unaria ::= INCREMENTO {: System.out.println("Operador unario: incremento"); RESULT = "++"; :} | DECREMENTO {: System.out.println("Operador unario: decremento"); RESULT = "--"; :};



expr_unaria ::= IDENTIFICADOR:idVar op_unaria:op {:  System.out.println("Operación unaria: " + idVar + op); RESULT = idVar.toString() + op; :};



sec_var ::= IDENTIFICADOR COMMA sec_var | IDENTIFICADOR;



imprimir ::= PRINT PARENTESIS_APERTURA sec_oper PARENTESIS_CIERRE {: System.out.println("Imprimir expresión"); :}; 
leer_var ::= READ PARENTESIS_APERTURA sec_var PARENTESIS_CIERRE {: System.out.println("Leer variables"); :}; 





actualizacion ::= ASIGNACION {: RESULT = "="; :} | op_aritmeticas:arit_op ASIGNACION {: RESULT = arit_op + "="; :};
asignacion_arreglo ::= IDENTIFICADOR:idVar ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE {: System.out.println("Asignación a un arreglo: " + idVar);
    RESULT = idVar + ":" + seq;
    agregarSimbolo(idVar.toString() + ":" + seq.toString());
:};




asignacion_indice ::= IDENTIFICADOR:idVar CORCHETE_APERTURA dato_general:dato CORCHETE_CIERRE actualizacion:act expr_logica_aritmetica:e 
{: System.out.println("Asignación por índice: " + idVar + "[" + dato + "] " + act + " " + e.toString());
    RESULT = idVar + ":" + dato + ":" + act + ":" + e.toString();
    agregarSimbolo(idVar.toString() + ":" + dato.toString() + ":" + act.toString() + ":" + e.toString());
:};




asignacion_variable ::= IDENTIFICADOR:idVar  actualizacion:act  expr_logica_aritmetica:e 
{:  System.out.println("Asignación de variable: " + idVar + " " + act + " " + e);
    RESULT = idVar + ":" + act + ":" + e.toString();
    agregarSimbolo(idVar.toString() + ":" + act + ":" + e.toString());
:};



asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;





declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE {: RESULT = seq.toString(); agregarSimbolo(seq.toString()); :} | {: RESULT = ""; :}; 
declaracion ::= tipo:t IDENTIFICADOR:idVar {: System.out.println("Declaración: " + t + " " + idVar); RESULT = t + ":" + idVar; :}
              | tipo:t IDENTIFICADOR:idVar ASIGNACION expr_logica_aritmetica:e {: System.out.println("Declaración con asignación: " + t + " " + idVar + " = " + e); RESULT = t + ":" + idVar + ":" + e; agregarSimbolo(t.toString() + ":" + idVar.toString() + ":" + e); :}
              | tipo:t IDENTIFICADOR:idVar CORCHETE_APERTURA dato_general:dato CORCHETE_CIERRE declaracion_arreglo_op:arr_decl {: String text = t + ":" + idVar + ":" + dato + ":" + arr_decl; System.out.println("Declaración arreglo: " + t + " " + idVar + "[" + dato + "]" + arr_decl); RESULT = text; agregarSimbolo(text); :};





else_expr ::= ELSE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE;
else_op ::= else_expr | {: RESULT = ""; :};





relacion ::= MENOR {: RESULT = "<"; :} | MENOR_IGUAL {: RESULT = "<="; :} | MAYOR {: RESULT = ">"; :} | MAYOR_IGUAL {: RESULT = ">="; :} | IGUALDAD {: RESULT = "=="; :} | DIFERENTE {: RESULT = "!="; :};





comparacion_operacion ::= expr_logica_aritmetica:e1  relacion:rel  expr_logica_aritmetica:e2 {: RESULT = e1.toString() + ":" + rel + ":" + e2.toString(); :} 
| expr_logica_aritmetica:e1  op_aritmeticas:op  expr_logica_aritmetica:e2 {: RESULT = e1 + ":" + op + ":" + e2; :}
| dato_general:dato {: RESULT = dato; :}
| expr_unaria:op {: RESULT = op; :}; 






op_logica ::= CONJUNCION {: RESULT = "and"; :} | DISYUNCION {: RESULT = "or"; :};





expr_logica_aritmetica ::= NEGACION expr_logica_aritmetica:e {: RESULT = "not " + e.toString(); agregarSimbolo("not:" + e); :} 
| expr_logica_aritmetica:e1  op_logica:op  expr_logica_aritmetica:e2 {: RESULT = e1.toString() + ":" + op + ":" + e2.toString(); agregarSimbolo(e1.toString() + ":" + op + ":" + e2); :} 
| comparacion_operacion:cmp {: RESULT = cmp; agregarSimbolo(cmp.toString()); :} 
| PARENTESIS_APERTURA expr_logica_aritmetica:e PARENTESIS_CIERRE {: RESULT = "(" + e.toString() + ")"; agregarSimbolo("(" + e + ")"); :}; //Se ha agregado el simbolo




if_expr ::= IF PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE else_op
| IF error {: System.out.println("Error sintáctico en la definición de un if."); :} APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE else_op;





cases ::= CASE literal DOS_PUNTOS bloques cases | DEFAULT DOS_PUNTOS bloques;
switch_expr ::= SWITCH PARENTESIS_APERTURA dato_general PARENTESIS_CIERRE APERTURA_DE_BLOQUE cases CIERRE_DE_BLOQUE
| SWITCH error {: System.out.println("Error sintáctico en la definición de una switch."); :} APERTURA_DE_BLOQUE   cases   CIERRE_DE_BLOQUE;





finfuncion ::= RETURN dato_general:dato {: System.out.println("Retorno del valor: " + dato.toString()); agregarSimbolo(dato.toString()); :} | RETURN {: System.out.println("Sin valor de retorno"); :};
op_simple ::= expr_unaria | asignacion_variable; 
simple_expr ::= expr_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | llamada_funcion | finfuncion | error {: RESULT = "Error"; System.out.println("Error sintáctico en la definición de una expresión simple."); :};
inicializacion ::= asignacion_variable:asign {: RESULT = asign; agregarSimbolo(asign.toString()); :} | IDENTIFICADOR:i {: RESULT = i; agregarSimbolo(i.toString()); :};





while_expr ::= WHILE PARENTESIS_APERTURA  expr_logica_aritmetica  PARENTESIS_CIERRE APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE 
| WHILE error {: System.out.println("Error sintáctico en la definición de un while."); :} APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE;

for_expr ::= FOR PARENTESIS_APERTURA  inicializacion  COMMA  expr_logica_aritmetica  COMMA  op_simple  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE 
| FOR error {: System.out.println("Error sintáctico en la definición de un for."); :} APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;





bloque ::= if_expr | while_expr | for_expr | switch_expr | simple_expr END_EXPR; 
bloques ::= bloque bloques | error {: System.out.println("Error dentro de bloque, verificar definición."); RESULT = "Error"; :} | ; 





funciones ::= funcion | funcion funciones | error {: System.out.println("Error fatal en la definición de una función, deteniendo parseo."); :};                                  
funcion ::= tipo:t nombrefuncion:funcName PARENTESIS_APERTURA  parametros_decl:params  {: System.out.println("Declaración de función: " + funcName + ", parámetros: " + "(" + params + "), " + "tipo: " + t.toString()); agregarSimbolo(t.toString() + ":" + funcName + ":" + params); :}  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE
| tipo nombrefuncion PARENTESIS_APERTURA  error {: System.out.println("Error en la definición de parámetros de una función."); :}  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;




programa ::= funciones {: imprimirTablaSimbolos(); :} | {: RESULT = ""; :};


/* ejecutar desde Lexical Analyzer */
/* java -cp lib/java-cup-11b.jar java_cup.Main -parser Parser -symbols sym -destdir src src/parser.cup */
