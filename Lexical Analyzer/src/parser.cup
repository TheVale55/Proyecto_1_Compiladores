//import java_cup.runtime.*;

parser code {: 
    private Lexer scanner;

    public Parser(Lexer scanner) {
        this.scanner = scanner;
    }

:};



//init with {: scanner.init(); :};

scan with {: return scanner.next_token(); :};



//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;


//bloques de c√≥digo
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;


//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;


//asignacion =
terminal ASIGNACION;


//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 


//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;


//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;


//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;


//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;


//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;


//funciones de leer
terminal PRINT, READ;


//identificadores
terminal IDENTIFICADOR;


//final de expresion y Main
terminal END_EXPR, MAIN;



non terminal tipo, literal, op_aritmeticas, dato_general, indice, sec_oper, sec_var, imprimir, leer_var, 
expr_aritmetica, actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion, op_logica, comparar_o_bool, expr_logica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, encabezado, funciones, funcion, programa, llamada_funcion, parametros_llamada;




//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;


precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;

start with programa;


//Reglas



nombrefuncion ::= MAIN | IDENTIFICADOR;
parametro_decl ::= tipo IDENTIFICADOR COMMA parametro_decl | tipo IDENTIFICADOR;
parametros_decl ::=  parametro_decl | ;
sec_oper ::= dato_general COMMA sec_oper | dato_general;
parametros_llamada ::= sec_oper | ;
llamada_funcion ::= nombrefuncion PARENTESIS_APERTURA  parametros_llamada  PARENTESIS_CIERRE;





tipo ::= INTEGER | FLOAT | BOOL | CHAR | STRING;
literal ::= INT_LITERAL | STRING_LITERAL | FLOAT_LITERAL | CHAR_LITERAL;
op_aritmeticas ::= SUMA | RESTA | MULTIPLICACION | DIVISION | MODULO | POTENCIA;
dato_general ::= IDENTIFICADOR | literal | llamada_funcion;
indice ::= INT_LITERAL | IDENTIFICADOR;





sec_var ::= IDENTIFICADOR COMMA sec_var | IDENTIFICADOR;
imprimir ::= PRINT PARENTESIS_APERTURA sec_oper PARENTESIS_CIERRE; 
leer_var ::= READ PARENTESIS_APERTURA  sec_var  PARENTESIS_CIERRE; 




expr_aritmetica ::= expr_aritmetica op_aritmeticas dato_general | dato_general;



actualizacion ::= ASIGNACION | op_aritmeticas ASIGNACION;
asignacion_arreglo ::= IDENTIFICADOR ASIGNACION APERTURA_DE_BLOQUE  sec_oper  CIERRE_DE_BLOQUE;
asignacion_indice ::= IDENTIFICADOR CORCHETE_APERTURA indice CORCHETE_CIERRE actualizacion expr_aritmetica;
asignacion_variable ::= IDENTIFICADOR actualizacion expr_aritmetica;
asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;




declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE  sec_oper  CIERRE_DE_BLOQUE | ; 
declaracion ::= tipo IDENTIFICADOR | tipo IDENTIFICADOR ASIGNACION expr_aritmetica | tipo IDENTIFICADOR CORCHETE_APERTURA indice CORCHETE_CIERRE declaracion_arreglo_op;




op_unaria ::= IDENTIFICADOR INCREMENTO | IDENTIFICADOR DECREMENTO;
else_expr ::= ELSE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;
else_op ::= else_expr | ;




relacion ::= MENOR | MENOR_IGUAL | MAYOR | MAYOR_IGUAL | IGUALDAD | DIFERENTE;
comparacion ::= dato_general  relacion  comparacion | dato_general; 
op_logica ::= CONJUNCION | DISYUNCION;
comparar_o_bool ::= comparacion | BOOL_LITERAL;
expr_logica ::= NEGACION comparar_o_bool expr_logica | expr_logica op_logica expr_logica | comparar_o_bool;
if_expr ::= IF PARENTESIS_APERTURA  expr_logica  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE else_op;




cases ::= CASE literal DOS_PUNTOS bloques cases | DEFAULT DOS_PUNTOS bloques;
switch_expr ::= SWITCH PARENTESIS_APERTURA  dato_general  PARENTESIS_CIERRE APERTURA_DE_BLOQUE   cases   CIERRE_DE_BLOQUE;





finfuncion ::= RETURN dato_general;
op_simple ::= op_unaria | asignacion_variable; 
simple_expr ::= op_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | finfuncion;
while_expr ::= WHILE PARENTESIS_APERTURA  expr_logica  PARENTESIS_CIERRE APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE;
for_expr ::= FOR PARENTESIS_APERTURA  declaracion  END_EXPR expr_logica  END_EXPR  op_simple  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;






bloque ::= if_expr | while_expr | for_expr | simple_expr END_EXPR | switch_expr; 
bloques ::= bloque bloques | ; 
encabezado ::= nombrefuncion PARENTESIS_APERTURA  parametros_decl  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;




funciones ::= funcion | funcion funciones;
funcion ::= tipo encabezado;



programa ::= funciones; 

//ejecutar desde Lexical Analyzer
//java -cp lib/java-cup-11b.jar java_cup.Main -parser Parser -symbols sym -destdir src src/parser.cup
