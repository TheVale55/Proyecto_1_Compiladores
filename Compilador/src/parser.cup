import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java_cup.runtime.Symbol;



parser code {: 
    private Lexer scanner;
    private SymbolTable symbolTable;
    private BufferedWriter syntaxFile;
    private BufferedWriter semanticFile;

    // Clase Node para encapsular información de los nodos
    public static class Node {
        private String value; // Valor del nodo (ej. "42", "+", "x")
        private int line;     // Línea en el código fuente
        private int column;   // Columna en el código fuente
        private Node left;    // Nodo izquierdo (opcional)
        private Node right;   // Nodo derecho (opcional)

        public Node(String value, int line, int column) {
            this.value = value;
            this.line = line;
            this.column = column;
        }

        public String getValue() { return value; }
        public int getLine() { return line; }
        public int getColumn() { return column; }
        public Node getLeft() { return left; }
        public void setLeft(Node left) { this.left = left; }
        public Node getRight() { return right; }
        public void setRight(Node right) { this.right = right; }

        @Override
        public String toString() {
            return value; // Convierte el nodo en un String cuando se necesite
        }
    }

    @SuppressWarnings("deprecation")
    public Parser(Lexer scanner) {
        this.scanner = scanner;
        this.symbolTable = new SymbolTable();
    }

    public void createSemanticWriter(String root) throws IOException {
        semanticFile = new BufferedWriter(new FileWriter(root));
    }


    public void createSyntaxWriter(String root) throws IOException {
        syntaxFile = new BufferedWriter(new FileWriter(root));
    }


    public void reportSyntaxError(int line, int column) throws IOException {
        if(syntaxFile != null) {
            syntaxFile.write("Error sintáctico recuperado en línea " + line + ", columna " + column + ".\n");
            syntaxFile.flush();
        }
    }


    public void reportSemanticError(String text) throws IOException {
        if(semanticFile != null) {
            semanticFile.write(text);
            semanticFile.flush();
        }
    }


    public void closeSyntaxWriter() throws IOException {
        if(syntaxFile != null) {
            syntaxFile.close();
        }
    }


    public void closeSemanticWriter() throws IOException {
        if(semanticFile != null) {
            semanticFile.close();
        }
    }


    @Override
    public void syntax_error(Symbol current) {
        try {
          reportSyntaxError(current.left, current.right);
        } catch (IOException e) {
          e.printStackTrace();
        }
    }

:};



scan with {: return scanner.next_token(); :};

//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;

//bloques de código
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;

//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;

//asignacion =
terminal ASIGNACION;

//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 

//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;

//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;

//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;

//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;

//funciones de leer
terminal PRINT, READ;

//identificadores
terminal IDENTIFICADOR;

//final de expresion y Main
terminal END_EXPR, MAIN;

non terminal tipo, literal, op_aritmeticas, dato_general, sec_oper, sec_var, imprimir, leer_var, inicializacion, 
actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion_operacion, op_logica, expr_logica_aritmetica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, funciones, funcion, programa, llamada_funcion, parametros_llamada, expr_unaria, acceso_arreglo, default_op;


//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;
precedence right INCREMENTO, DECREMENTO;

start with programa;



//Reglas gramáticales


// Regla para la declaración de parámetros en una función.
parametro_decl ::= tipo:t IDENTIFICADOR:idVar COMMA parametro_decl:param 
    {: 
        String idVarName = (String) ((Symbol) idVar).value;
        String typeName = (String) ((Symbol) t).value;

        int left = ((Symbol) idVar).left;
        int right = ((Symbol) idVar).right;

        // Verificar si ya existe en la tabla de símbolos
        if(!symbolTable.addSymbol(idVarName, typeName + ":" + idVarName)) {
            reportSemanticError("Error semántico en la declaración de una función, hay parámetros repetidos en línea " + left + ".\n");
        } 

        RESULT = new Node(typeName, left, right);
    :}
    | tipo:t IDENTIFICADOR:idVar 
    {: 
        String idVarName = (String) ((Symbol) idVar).value;
        String typeName = (String) ((Symbol) t).value;


        int left = ((Symbol) idVar).left;
        int right = ((Symbol) idVar).right;

        if(!symbolTable.addSymbol(idVarName, typeName + ":" + idVarName)) {
            reportSemanticError("Error semántico en la declaración de una función, hay parámetros repetidos en línea " + left + ".\n");
        } 

        RESULT = new Node(typeName, left, right); 
    :};


// Regla para definir el conjunto completo de parámetros en una función.
parametros_decl ::= parametro_decl:params {: RESULT = params; :} | {: RESULT = new Node("empty_params", -1, -1); :};



// Regla para las operaciones en las llamadas a funciones.
// Regla para las operaciones en las llamadas a funciones.
sec_oper ::= expr_logica_aritmetica:dato COMMA sec_oper:seq 
    {:
        Node datoNode = (Node) dato; // Casting a Node
        Node seqNode = (Node) seq;   // Casting a Node

        Node opNode = new Node(datoNode.getValue() + ":" + seqNode.getValue(), datoNode.getLine(), datoNode.getColumn());
        opNode.setLeft(datoNode);
        opNode.setRight(seqNode);
        RESULT = opNode;
    :}
    | expr_logica_aritmetica:dato 
    {:
        RESULT = (Node) dato;  // Casting a Node
    :};



// Definición de los parámetros en las llamadas a funciones.
parametros_llamada ::= sec_oper:seq {: RESULT = (Node) seq; :} | {: RESULT = new Node("empty_call_params", -1, -1); :};


llamada_funcion ::= nombrefuncion:f PARENTESIS_APERTURA parametros_llamada:params PARENTESIS_CIERRE 
    {:
        // Casting seguro a Node
        Node funcNameNode = (Node) f;
        Node paramsNode = (Node) params;

        // Crear nodo de la función con su nombre
        Node funcNode = new Node(funcNameNode.getValue(), funcNameNode.getLine(), funcNameNode.getColumn());
        
        // Agregar los parámetros como hijo izquierdo
        funcNode.setLeft(paramsNode);

        // Asignar el resultado
        RESULT = funcNode;

        // Verifica que la llamada sea válida en términos de parámetros y existencia.
        if (!symbolTable.verifyFunctionCall(funcNameNode.getValue(), paramsNode.getValue())) {
            reportSemanticError("Error en la llamada a la función: tipo de datos incorrecto, función inexistente o cantidad incorrecta de parámetros en línea " + funcNameNode.getLine() + ".\n");
        }
    :};



// Definición de tipos básicos.
tipo ::= INTEGER {: RESULT = new Node("int", -1, -1); :}
        | FLOAT {: RESULT = new Node("float", -1, -1); :}
        | BOOL {: RESULT = new Node("bool", -1, -1); :}
        | CHAR {: RESULT = new Node("char", -1, -1); :}
        | STRING {: RESULT = new Node("string", -1, -1); :};


// Reglas para literales de diferentes tipos.
literal ::= INT_LITERAL:intVar {:Symbol intSymbol = (Symbol) intVar;RESULT = new Node(intSymbol.value.toString(), intSymbol.left, intSymbol.right);:}
        | STRING_LITERAL:strVar {:Symbol strSymbol = (Symbol) strVar;RESULT = new Node(strSymbol.value.toString(), strSymbol.left, strSymbol.right);:}
        | FLOAT_LITERAL:floatVar {:Symbol floatSymbol = (Symbol) floatVar;RESULT = new Node(floatSymbol.value.toString(), floatSymbol.left, floatSymbol.right);:}
        | CHAR_LITERAL:charVar {:Symbol charSymbol = (Symbol) charVar;RESULT = new Node(charSymbol.value.toString(), charSymbol.left, charSymbol.right);:}
        | BOOL_LITERAL:boolVar {:Symbol boolSymbol = (Symbol) boolVar; RESULT = new Node(boolSymbol.value.toString(), boolSymbol.left, boolSymbol.right);:};


// Operadores aritméticos básicos.
op_aritmeticas ::= SUMA {: RESULT = new Node("+", -1, -1); :} 
                | RESTA {: RESULT = new Node("-", -1, -1); :} 
                | MULTIPLICACION {: RESULT = new Node("*", -1, -1); :} 
                | DIVISION {: RESULT = new Node("/", -1, -1); :} 
                | MODULO {: RESULT = new Node("%", -1, -1); :} 
                | POTENCIA {: RESULT = new Node("^", -1, -1); :};



// Regla para datos generales: identificadores, literales, funciones o arreglos.
dato_general ::= IDENTIFICADOR:idVar {: Symbol idSymbol = (Symbol) idVar; RESULT = new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right); :} 
                | literal:lit {: RESULT = lit; :} 
                | llamada_funcion:func {: RESULT = func; :} 
                | acceso_arreglo:arrName {: RESULT = arrName; :};


// Operadores unarios como incremento y decremento.
op_unaria ::= INCREMENTO {: RESULT = new Node("++", -1, -1); :} | DECREMENTO {: RESULT = new Node("--", -1, -1); :};


// Expresiones unarias, aplicadas sobre identificadores.
expr_unaria ::= IDENTIFICADOR:idVar op_unaria:op 
    {:  

        Symbol idSymbol = (Symbol) idVar;
        Symbol opSymbol = (Symbol) op;

        Node unariaNode = new Node(opSymbol.value.toString(), idSymbol.left, idSymbol.right);
        
        Node idNode = new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right);
        unariaNode.setLeft(idNode);

        if (!symbolTable.isInLocalScope(idSymbol.value.toString())) {
            reportSemanticError("Error semántico, identificador fuera del scope en línea " + idSymbol.left + ".\n");
        }

        RESULT = unariaNode;
    :};



// Secuencia de variables separadas por comas.
sec_var ::= IDENTIFICADOR COMMA sec_var | IDENTIFICADOR;


// Simplificación para imprimir un único valor.
imprimir ::= PRINT PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE; //A petición del profe, se simplifica a un solo valor.
// Leer un valor desde la entrada del usuario.
leer_var ::= READ PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE; 


// Leer un valor desde la entrada del usuario.
acceso_arreglo ::= IDENTIFICADOR:idVar CORCHETE_APERTURA expr_logica_aritmetica:e CORCHETE_CIERRE 
    {: 
        Symbol idSymbol = (Symbol) idVar;
        Node indexNode = (Node) e; 

        if (!symbolTable.isIndexInteger(indexNode.getValue())) {
            reportSemanticError("Error semántico, el tipo de dato de un índice debe ser entero en línea " + idSymbol.left + ".\n");
        }

        Node arrayAccessNode = new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right);
        
        arrayAccessNode.setLeft(indexNode);

        RESULT = arrayAccessNode;
    :};


// Regla para actualización de valores en asignaciones.
actualizacion ::= ASIGNACION {: RESULT = new Node("=", -1, -1); :} 
                | op_aritmeticas:arit_op ASIGNACION {: Node aritNode = (Node) arit_op; RESULT = new Node(aritNode.getValue() + "=", -1, -1); :};

// Regla para asignación a un arreglo.
asignacion_arreglo ::= IDENTIFICADOR:idVar ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE 
    {:
        Symbol idSymbol = (Symbol) idVar;
        Node seqNode = (Node) seq; 

        Node arrayAssignNode = new Node("=", idSymbol.left, idSymbol.right);

        Node arrayNode = new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right);
        arrayAssignNode.setLeft(arrayNode);

        arrayAssignNode.setRight(seqNode);

        if (!symbolTable.verifyArrayDeclaration(symbolTable.getType(idSymbol.value.toString()), seqNode.getValue())) { 
            reportSemanticError("Error en la asignación al arreglo: tipo de datos incorrecto o variable fuera del scope en línea " + idSymbol.left + ".\n");
        }

        RESULT = arrayAssignNode;
    :};



// Regla para actualización de valores en asignaciones.
asignacion_indice ::= acceso_arreglo:arr actualizacion:act expr_logica_aritmetica:e 
    {:
        Node arrNode = (Node) arr;  
        Node actNode = (Node) act;  
        Node exprNode = (Node) e;   

        Node indexAssignNode = new Node(actNode.getValue(), arrNode.getLine(), arrNode.getColumn());
        indexAssignNode.setLeft(arrNode);
        indexAssignNode.setRight(exprNode);

        if (!symbolTable.verifyType(symbolTable.getType(arrNode.getValue()), exprNode.getValue())) {
            reportSemanticError("Error en la asignación a índice: tipo de datos incorrecto o variable fuera del scope en línea " + arrNode.getLine() + ".\n");
        }

        RESULT = indexAssignNode;
    :};



// Asignación de valores a una variable.
asignacion_variable ::= IDENTIFICADOR:idVar actualizacion:act expr_logica_aritmetica:e 
    {:
        Symbol idSymbol = (Symbol) idVar; 
        Node actNode = (Node) act;        
        Node exprNode = (Node) e;         

        Node assignNode = new Node(actNode.getValue(), idSymbol.left, idSymbol.right);
    
        Node idNode = new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right);
        assignNode.setLeft(idNode);

        assignNode.setRight(exprNode);

        if (!symbolTable.verifyType(symbolTable.getType(idSymbol.value.toString()), exprNode.getValue())) {
            reportSemanticError("Error en la asignación a variable: tipo de datos incorrecto o variable fuera del scope en línea " + idSymbol.left + ".\n");
        }

        RESULT = assignNode;
    :};


// Regla general para asignaciones: puede ser a una variable, arreglo o un índice de arreglo.
asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;



// Declaración opcional de un arreglo, con o sin asignación de valores iniciales.
declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE {: RESULT = (Node) seq; :} | {: RESULT = new Node("empty_array_init", -1, -1); :};


// Declaración de variables, con validaciones semánticas.
declaracion ::= tipo:t IDENTIFICADOR:idVar 
    {:
        Symbol typeSymbol = (Symbol) t;
        Symbol idSymbol = (Symbol) idVar;

        Node declNode = new Node(typeSymbol.value.toString(), idSymbol.left, idSymbol.right);

        if (!symbolTable.addSymbol(idSymbol.value.toString(), typeSymbol.value.toString() + ":" + idSymbol.value.toString())) {
            reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope en línea " + idSymbol.left + ".\n");
        } 

        RESULT = declNode;
    :} 

    | tipo:t IDENTIFICADOR:idVar ASIGNACION expr_logica_aritmetica:e 
    {:
        Symbol typeSymbol = (Symbol) t;
        Symbol idSymbol = (Symbol) idVar;
        Node exprNode = (Node) e;

        Node declAssignNode = new Node("=", idSymbol.left, idSymbol.right);
        declAssignNode.setLeft(new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right));
        declAssignNode.setRight(exprNode);

        if (!symbolTable.addSymbol(idSymbol.value.toString(), typeSymbol.value.toString() + ":" + idSymbol.value.toString())) {
            reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope en línea " + idSymbol.left + ".\n");
        } 

        if (!symbolTable.verifyType(typeSymbol.value.toString(), exprNode.getValue())) {
            reportSemanticError("Error en el tipo de datos en la asignación de una declaración o existencia de una variable fuera del scope en línea " + idSymbol.left + ".\n");
        }

        RESULT = declAssignNode;
    :}

    | tipo:t acceso_arreglo:arrName declaracion_arreglo_op:arr_decl 
    {:
        Symbol typeSymbol = (Symbol) t;
        Node arrNode = (Node) arrName;
        Node arrDeclNode = (Node) arr_decl;

        Node arrayDeclNode = new Node("array_decl", arrNode.getLine(), arrNode.getColumn());
        arrayDeclNode.setLeft(new Node(typeSymbol.value.toString(), -1, -1));
        arrayDeclNode.setRight(arrDeclNode);

        if (!symbolTable.addSymbol(arrNode.getValue(), typeSymbol.value.toString() + ":" + arrNode.getValue())) {
            reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope en línea " + arrNode.getLine() + ".\n");
        }  

        if (!symbolTable.verifyType(typeSymbol.value.toString(), arrDeclNode.getValue())) {
            reportSemanticError("Error en el tipo de datos en la asignación de una declaración o existencia de una variable fuera del scope en línea " + arrNode.getLine() + ".\n");
        }

        RESULT = arrayDeclNode;
    :};





// Definición de una cláusula else opcional.
else_expr ::= ELSE APERTURA_DE_BLOQUE {: symbolTable.addScope(); :}  bloques CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}; 

// Definición del operador else como opcional.
else_op ::= else_expr | {: RESULT = new Node("no_else", -1, -1); :};

// Relación entre dos expresiones (comparaciones).
relacion ::= MENOR {: RESULT = new Node("<", -1, -1); :} 
            | MENOR_IGUAL {: RESULT = new Node("<=", -1, -1); :} 
            | MAYOR {: RESULT = new Node(">", -1, -1); :} 
            | MAYOR_IGUAL {: RESULT = new Node(">=", -1, -1); :} 
            | IGUALDAD {: RESULT = new Node("==", -1, -1); :} 
            | DIFERENTE {: RESULT = new Node("!=", -1, -1); :};


// Comparaciones y operaciones aritméticas.
comparacion_operacion ::= expr_logica_aritmetica:e1 relacion:rel expr_logica_aritmetica:e2 
    {:
        // Casting seguro
        Node leftExpr = (Node) e1;
        Node rightExpr = (Node) e2;
        Node relNode = (Node) rel;

        // Crear nodo de comparación
        Node opNode = new Node(relNode.getValue(), leftExpr.getLine(), leftExpr.getColumn());
        opNode.setLeft(leftExpr);
        opNode.setRight(rightExpr);

        // Validar la operación en la tabla de símbolos
        if (!symbolTable.validateOperation(leftExpr.getValue(), relNode.getValue(), rightExpr.getValue())) {
            reportSemanticError("Error semántico al operar o comparar tipos que no son compatibles o están fuera del scope en línea " + leftExpr.getLine() + ".\n");
        }

        RESULT = opNode;
    :} 

    | expr_logica_aritmetica:e1 op_aritmeticas:op expr_logica_aritmetica:e2 
    {:
        // Casting seguro
        Node leftExpr = (Node) e1;
        Node rightExpr = (Node) e2;
        Node opNode = (Node) op;

        // Crear nodo de operación aritmética
        Node arithNode = new Node(opNode.getValue(), leftExpr.getLine(), leftExpr.getColumn());
        arithNode.setLeft(leftExpr);
        arithNode.setRight(rightExpr);

        // Validar la operación en la tabla de símbolos
        if (!symbolTable.validateOperation(leftExpr.getValue(), opNode.getValue(), rightExpr.getValue())) {
            reportSemanticError("Error semántico al operar o comparar tipos que no son compatibles o están fuera del scope en línea " + leftExpr.getLine() + ".\n");
        }

        RESULT = arithNode;
    :} 

    | dato_general:dato 
    {:
        Node dataNode = (Node) dato;

        // Validar si el dato está dentro del scope o es un tipo válido
        if (!symbolTable.isDataType(dataNode.getValue()) && !symbolTable.isInLocalScope(dataNode.getValue())) {
            reportSemanticError("Error semántico, variable fuera del scope en línea " + dataNode.getLine() + ".\n");
        }

        RESULT = dataNode;
    :} 

    | expr_unaria:op 
    {:
        RESULT = (Node) op; // Casting a Node
    :};
 



// Operadores lógicos  and y or  
op_logica ::= CONJUNCION {: RESULT = new Node("and", -1, -1); :} | DISYUNCION {: RESULT = new Node("or", -1, -1); :};




// Expresiones lógicas y aritméticas con validaciones.
expr_logica_aritmetica ::= NEGACION expr_logica_aritmetica:e 
    {:
        Node exprNode = (Node) e;
        Node negNode = new Node("not", exprNode.getLine(), exprNode.getColumn());
        negNode.setLeft(exprNode);
        RESULT = negNode;
    :} 
    | expr_logica_aritmetica:e1 op_logica:op expr_logica_aritmetica:e2 
    {:
        Node leftExpr = (Node) e1;
        Node rightExpr = (Node) e2;
        Node opNode = (Node) op;
        
        Node logicalOpNode = new Node(opNode.getValue(), leftExpr.getLine(), leftExpr.getColumn());
        logicalOpNode.setLeft(leftExpr);
        logicalOpNode.setRight(rightExpr);
        
        RESULT = logicalOpNode;
    :} 
    | comparacion_operacion:cmp 
    {:
        RESULT = (Node) cmp;
    :} 
    | PARENTESIS_APERTURA expr_logica_aritmetica:e PARENTESIS_CIERRE 
    {:
        RESULT = (Node) e;
    :};




// Expresiones lógicas y aritméticas con validaciones.
if_expr ::= IF PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}   bloques   CIERRE_DE_BLOQUE  {: symbolTable.printScope(); symbolTable.exitScope(); :}  else_op
| IF error {: System.out.println("Error sintáctico en la definición de un if."); :} APERTURA_DE_BLOQUE {: symbolTable.addScope(); :} bloques CIERRE_DE_BLOQUE  {: symbolTable.printScope(); symbolTable.exitScope(); :}  else_op;


// Definición de un caso por defecto en una estructura SWITCH.
default_op ::= DEFAULT DOS_PUNTOS bloques | ;

// Definición de casos en una estructura SWITCH
cases ::= CASE literal DOS_PUNTOS bloques cases | CASE literal DOS_PUNTOS bloques;

// Definición de una estructura SWITCH con casos y un DEFAULT opcional.
switch_expr ::= SWITCH PARENTESIS_APERTURA dato_general PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  cases   default_op   CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}
| SWITCH error {: System.out.println("Error sintáctico en la definición de una switch."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  cases   default_op   CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};



// Definición de la expresión RETURN dentro de funciones, con validación de tipos
finfuncion ::= RETURN expr_logica_aritmetica:dato 
{:
     // Verifica que el tipo de retorno sea compatible con el tipo declarado de la función.
    if(!symbolTable.verifyType(symbolTable.getType(dato.toString()), symbolTable.getActualFunction())) {
        reportSemanticError("Error semántico en el tipo de retorno de función.\n");
    } 
:} | RETURN {: reportSemanticError("Error semántico, el valor de retorno no coincide con el tipo de la función.\n"); :};



// Operaciones simples que pueden ser expresiones unarias o asignaciones.
op_simple ::= expr_unaria | asignacion_variable;

// Expresiones simples, como declaraciones, asignaciones, lectura/escritura, o llamadas a funciones.
simple_expr ::= expr_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | llamada_funcion | finfuncion | error 
              {: RESULT = new Node("error_expr", -1, -1); System.out.println("Error sintáctico en la definición de una expresión simple."); :};

// Inicialización de variables, que puede ser una asignación o declaración.
inicializacion ::= asignacion_variable:asign {: RESULT = (Node) asign; :} | IDENTIFICADOR:i 
{: 
    Symbol idSymbol = (Symbol) i;

    Node idNode = new Node(idSymbol.value.toString(), idSymbol.left, idSymbol.right);

    if (!symbolTable.isInLocalScope(idSymbol.value.toString())) {
        reportSemanticError("Error semántico, identificador fuera del scope en línea " + idSymbol.left + ".\n");
    }
:} | tipo asignacion_variable:asign {: RESULT = (Node) asign; :};



// Estructura de control WHILE, con validación de bloques y manejo de scopes.
while_expr ::= WHILE PARENTESIS_APERTURA  expr_logica_aritmetica  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :} 
| WHILE error {: System.out.println("Error sintáctico en la definición de un while."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};

// Estructura de control FOR con inicialización, condición, y actualización.
for_expr ::= FOR PARENTESIS_APERTURA  inicializacion  COMMA  expr_logica_aritmetica  COMMA  op_simple  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}   bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}
| FOR error {: System.out.println("Error sintáctico en la definición de un for."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};



// Un único bloque de código puede ser un IF, WHILE, FOR, SWITCH, o una expresión simple.
bloque ::= if_expr | while_expr | for_expr | switch_expr | simple_expr END_EXPR; 

// Secuencia de bloques de código (uno tras otro).
bloques ::= bloque bloques 
          | error {: System.out.println("Error dentro de bloque, verificar definición."); RESULT = new Node("error_block", -1, -1); :} 
          | ;


// Definición de nombres de funciones, incluyendo el nombre especial MAIN.
nombrefuncion ::= MAIN {:RESULT = new Node("_verano_", -1, -1); :} 
                | IDENTIFICADOR:nombreFunc {: RESULT = new Node(nombreFunc.toString(), -1, -1); :};



// Conjunto de funciones en el programa.
funciones ::= funcion | funcion funciones | error {: System.out.println("Error fatal en la definición de una función, deteniendo parseo."); :}; 


// Definición de una función con su tipo, nombre, parámetros y cuerpo.
funcion ::= tipo:t nombrefuncion:funcName PARENTESIS_APERTURA {: symbolTable.addScope(); symbolTable.setActualFunction(funcName.toString()); :}  parametros_decl:params  PARENTESIS_CIERRE 
{:
    if(!symbolTable.addGlobalSymbol(funcName.toString(), t + ":" + funcName + ":" + params)) {
        reportSemanticError("Error semántico durante declaración, ya existe una función con el mismo nombre.\n");
    }
:}  
{: 
    symbolTable.printScope(); 
    symbolTable.exitScope();
    symbolTable.setActualFunction(""); 
:} | 
tipo:t nombrefuncion:funcName PARENTESIS_APERTURA {: symbolTable.addScope(); symbolTable.setActualFunction(funcName.toString()); :}  error  PARENTESIS_CIERRE 
{:
    if(!symbolTable.addGlobalSymbol(funcName.toString(), t + ":" + funcName + ":error")) {
        reportSemanticError("Error semántico durante declaración, ya existe una función con el mismo nombre.\n");
    }
:} 
APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE 
{: 
    System.out.println("Error en la definición de parámetros de una función."); 
    symbolTable.printScope(); 
    symbolTable.exitScope(); 
    symbolTable.setActualFunction("");
:};



// Definición del programa principal, compuesto por funciones
programa ::= funciones {: symbolTable.printGlobalScope(); :} 
          | {: RESULT = new Node("empty_program", -1, -1); :};


/* ejecutar desde Compilador */
/* java -cp lib/java-cup-11b.jar java_cup.Main -parser Parser -symbols sym -destdir src src/parser.cup */
