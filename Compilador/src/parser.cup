import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java_cup.runtime.Symbol;



parser code {: 
    private Lexer scanner;
    private SymbolTable symbolTable;
    private BufferedWriter syntaxFile;
    private BufferedWriter semanticFile;


    @SuppressWarnings("deprecation")
    public Parser(Lexer scanner) {
        this.scanner = scanner;
        this.symbolTable = new SymbolTable();
    }

    public void createSemanticWriter(String root) throws IOException {
        semanticFile = new BufferedWriter(new FileWriter(root));
    }


    public void createSyntaxWriter(String root) throws IOException {
        syntaxFile = new BufferedWriter(new FileWriter(root));
    }


    public void reportSyntaxError(int line, int column) throws IOException {
        if(syntaxFile != null) {
            syntaxFile.write("Error sintáctico recuperado en línea " + line + ", columna " + column + ".\n");
            syntaxFile.flush();
        }
    }


    public void reportSemanticError(String text) throws IOException {
        if(semanticFile != null) {
            semanticFile.write(text);
            semanticFile.flush();
        }
    }


    public void closeSyntaxWriter() throws IOException {
        if(syntaxFile != null) {
            syntaxFile.close();
        }
    }


    public void closeSemanticWriter() throws IOException {
        if(semanticFile != null) {
            semanticFile.close();
        }
    }


    @Override
    public void syntax_error(Symbol current) {
        try {
          reportSyntaxError(current.left, current.right);
        } catch (IOException e) {
          e.printStackTrace();
        }
    }

:};



scan with {: return scanner.next_token(); :};

//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;

//bloques de código
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;

//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;

//asignacion =
terminal ASIGNACION;

//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 

//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;

//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;

//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;

//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;

//funciones de leer
terminal PRINT, READ;

//identificadores
terminal IDENTIFICADOR;

//final de expresion y Main
terminal END_EXPR, MAIN;

non terminal tipo, literal, op_aritmeticas, dato_general, sec_oper, sec_var, imprimir, leer_var, inicializacion, 
actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion_operacion, op_logica, expr_logica_aritmetica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, funciones, funcion, programa, llamada_funcion, parametros_llamada, expr_unaria, acceso_arreglo, default_op;


//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;
precedence right INCREMENTO, DECREMENTO;

start with programa;



//Reglas


parametro_decl ::= tipo:t IDENTIFICADOR:idVar COMMA parametro_decl:param 
{: 
    if(!symbolTable.addSymbol(idVar.toString(), t + ":" + idVar)) {
        reportSemanticError("Error semántico en la declaración de una función, hay parámetros repetidos.\n");
    } 
    RESULT = t + ":"  + param; 
:}
| tipo:t IDENTIFICADOR:idVar 
{: 
    if(!symbolTable.addSymbol(idVar.toString(), t + ":" + idVar)) {
        reportSemanticError("Error semántico en la declaración de una función, hay parámetros repetidos.\n");
    } 
    RESULT = t.toString(); 
:};




parametros_decl ::= parametro_decl:params {: RESULT = params; :} | {: RESULT = ""; :};



sec_oper ::= expr_logica_aritmetica:dato COMMA sec_oper:seq {: RESULT = dato + ":" + seq; :} | expr_logica_aritmetica:dato {: RESULT = dato; :};



parametros_llamada ::= sec_oper:seq {: RESULT = seq; :} | {: RESULT = ""; :} ;





llamada_funcion ::= nombrefuncion:f PARENTESIS_APERTURA parametros_llamada:params PARENTESIS_CIERRE 
{:
    String funcName = f.toString();
    RESULT = symbolTable.getType(funcName);
    if(!symbolTable.verifyFunctionCall(funcName, params.toString())) {
        reportSemanticError("Error en el tipo de datos de una llamada a una función o existencia de una variable o función fuera del scope o cantidad incorrecta de parámetros.\n");
    }
:};





tipo ::= INTEGER {: RESULT = "int"; :}
        | FLOAT {: RESULT = "float"; :}
        | BOOL {: RESULT = "bool"; :}
        | CHAR {: RESULT = "char"; :}
        | STRING {: RESULT = "string"; :};



literal ::= INT_LITERAL:intVar {: RESULT = "int"; /* intVar.toString(); */ :}
          | STRING_LITERAL:strVar {: RESULT = "string"; /* strVar.toString(); */ :}
          | FLOAT_LITERAL:floatVar {: RESULT = "float"; /* floatVar.toString(); */ :}
          | CHAR_LITERAL:charVar {:  RESULT = "char"; /* charVar.toString(); */ :}
          | BOOL_LITERAL:boolVar {:  RESULT = "bool"; /* boolVar.toString(); */ :};





op_aritmeticas ::= SUMA {: RESULT = "+"; :} | RESTA {: RESULT = "-"; :} | MULTIPLICACION {: RESULT = "*"; :} | DIVISION {:  RESULT = "/"; :} | MODULO {: RESULT = "%"; :} | POTENCIA {:  RESULT = "^"; :};



dato_general ::= IDENTIFICADOR:idVar {: RESULT = idVar.toString(); :} | literal:lit {: RESULT = lit; :} | llamada_funcion:func {: RESULT = func; :} | acceso_arreglo:arrName {: RESULT = arrName; :};



op_unaria ::= INCREMENTO {:  RESULT = "++"; :} | DECREMENTO {:  RESULT = "--"; :};



expr_unaria ::= IDENTIFICADOR:idVar op_unaria 
{:  
    String var = idVar.toString();
    RESULT = var; 
    if(!symbolTable.isInLocalScope(var)) {
        reportSemanticError("Error semántico, identificador fuera del scope.\n");
    }
:};



sec_var ::= IDENTIFICADOR COMMA sec_var | IDENTIFICADOR;



imprimir ::= PRINT PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE; //A petición del profe, se simplifica a un solo valor.
leer_var ::= READ PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE; 





acceso_arreglo ::= IDENTIFICADOR:idVar CORCHETE_APERTURA expr_logica_aritmetica:e CORCHETE_CIERRE 
{: 
    if(!symbolTable.isIndexInteger(e.toString())) {
        reportSemanticError("Error semántico, el tipo de dato de un índice debe ser entero.\n");
    }
    RESULT = idVar.toString(); 
:};





actualizacion ::= ASIGNACION {: RESULT = "="; :} | op_aritmeticas:arit_op ASIGNACION {: RESULT = arit_op + "="; :};
asignacion_arreglo ::= IDENTIFICADOR:idVar ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE 
{:
    RESULT = idVar + ":" + seq;
    if(!symbolTable.verifyArrayDeclaration(symbolTable.getType(idVar.toString()), seq.toString())) { 
        reportSemanticError("Error en el tipo de datos de una asignación o hay una variable que está fuera del scope.\n");
    }

:};





asignacion_indice ::= acceso_arreglo:arr actualizacion:act expr_logica_aritmetica:e 
{:
    String arrName = arr.toString();
    RESULT = arrName;                         
    if(!symbolTable.verifyType(symbolTable.getType(arrName), e.toString())) {
        reportSemanticError("Error en el tipo de datos de una asignación o hay una variable que está fuera del scope.\n");
    }
:};




asignacion_variable ::= IDENTIFICADOR:idVar  actualizacion:act  expr_logica_aritmetica:e 
{: 
    RESULT = idVar + ":" + act + ":" + e.toString();
    if(!symbolTable.verifyType(symbolTable.getType(idVar.toString()), e.toString())) {
        reportSemanticError("Error en el tipo de datos de una asignación o hay una variable que está fuera del scope.\n");
    }
:};



asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;




declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE {: RESULT = seq.toString(); :} | {: RESULT = ""; :}; 




declaracion ::= tipo:t IDENTIFICADOR:idVar 
              {: 
                String type = t.toString(); 
                RESULT = type; 
                if(!symbolTable.addSymbol(idVar.toString(), type + ":" + idVar)) {
                    reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope.\n");
                } 
              :}
              | tipo:t IDENTIFICADOR:idVar ASIGNACION expr_logica_aritmetica:e 
              {:     
                    String type = t.toString();
                    RESULT = type; 
                    if(!symbolTable.addSymbol(idVar.toString(), type + ":" + idVar)) {
                        reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope.\n");
                    } 
                    if(!symbolTable.verifyType(type, e.toString())) {
                        reportSemanticError("Error en el tipo de datos en la asignación de una declaración o existencia de una variable fuera del scope.\n");
                    }
              :}
              | tipo:t acceso_arreglo:arrName declaracion_arreglo_op:arr_decl 
              {:    
                    String text = t.toString();  
                    RESULT = text; 
                    if(!symbolTable.addSymbol(arrName.toString(), text + ":" + arrName)) {
                        reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope.\n");
                    }  
                    if(!symbolTable.verifyType(t.toString(), arr_decl.toString())) {
                        reportSemanticError("Error en el tipo de datos en la asignación de una declaración o existencia de una variable fuera del scope.\n");
                    }
              :};





else_expr ::= ELSE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}; 
else_op ::= else_expr | {: RESULT = ""; :};





relacion ::= MENOR {: RESULT = "<"; :} | MENOR_IGUAL {: RESULT = "<="; :} | MAYOR {: RESULT = ">"; :} | MAYOR_IGUAL {: RESULT = ">="; :} | IGUALDAD {: RESULT = "=="; :} | DIFERENTE {: RESULT = "!="; :};





comparacion_operacion ::= expr_logica_aritmetica:e1  relacion:rel  expr_logica_aritmetica:e2 
{: 
    if(!symbolTable.validateOperation(e1.toString(), rel.toString(), e2.toString())) {
        reportSemanticError("Error semántico al operar o comparar tipos que no son compatibles o están fuera del scope.\n");
    }
    RESULT = e1.toString(); 
:} | expr_logica_aritmetica:e1  op_aritmeticas:op  expr_logica_aritmetica:e2 
{: 
    if(!symbolTable.validateOperation(e1.toString(), op.toString(), e2.toString())) {
        reportSemanticError("Error semántico al operar o comparar tipos que no son compatibles o están fuera del scope.\n");
    }
    RESULT = e1.toString(); 

:} 
| dato_general:dato 
{: 
    String operando = dato.toString();
    RESULT = operando;
    if(!symbolTable.isDataType(operando) && !symbolTable.isInLocalScope(operando)) {
        reportSemanticError("Error semantico, variable fuera del scope.\n");
    }

:} | expr_unaria:op {: RESULT = op; :}; 



 
op_logica ::= CONJUNCION {: RESULT = "and"; :} | DISYUNCION {: RESULT = "or"; :};




expr_logica_aritmetica ::= NEGACION expr_logica_aritmetica:e 
{: 
    RESULT = e.toString(); 
:} 
| expr_logica_aritmetica:e1  op_logica:op  expr_logica_aritmetica:e2 
{: 
    /* Aqui no verifico porque se trata de operaciones logicas como and, or o not */
    RESULT = e1.toString();  
:} 
| comparacion_operacion:cmp 
{: 
    RESULT = cmp; 
:} 
| PARENTESIS_APERTURA expr_logica_aritmetica:e PARENTESIS_CIERRE 
{: 
    RESULT = e.toString(); 
:}; 




if_expr ::= IF PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}   bloques   CIERRE_DE_BLOQUE  {: symbolTable.printScope(); symbolTable.exitScope(); :}  else_op
| IF error {: System.out.println("Error sintáctico en la definición de un if."); :} APERTURA_DE_BLOQUE {: symbolTable.addScope(); :} bloques CIERRE_DE_BLOQUE  {: symbolTable.printScope(); symbolTable.exitScope(); :}  else_op;




default_op ::= DEFAULT DOS_PUNTOS bloques | ;
cases ::= CASE literal DOS_PUNTOS bloques cases | CASE literal DOS_PUNTOS bloques;
switch_expr ::= SWITCH PARENTESIS_APERTURA dato_general PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  cases   default_op   CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}
| SWITCH error {: System.out.println("Error sintáctico en la definición de una switch."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  cases   default_op   CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};




finfuncion ::= RETURN expr_logica_aritmetica:dato 
{: 
    if(!symbolTable.verifyType(symbolTable.getType(dato.toString()), symbolTable.getActualFunction())) {
        reportSemanticError("Error semántico en el tipo de retorno de función.\n");
    } 
:} | RETURN {: reportSemanticError("Error semántico, el valor de retorno no coincide con el tipo de la función.\n"); :};




op_simple ::= expr_unaria | asignacion_variable; 
simple_expr ::= expr_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | llamada_funcion | finfuncion | error {: RESULT = "Error"; System.out.println("Error sintáctico en la definición de una expresión simple."); :};
inicializacion ::= asignacion_variable:asign {: RESULT = asign; :} | IDENTIFICADOR:i 
{: 
    RESULT = i; 
    if(!symbolTable.isInLocalScope(i.toString())) {
        reportSemanticError("Error semántico, identificador fuera del scope.\n");
    }
:} | tipo asignacion_variable:asign {: RESULT = asign; :};






while_expr ::= WHILE PARENTESIS_APERTURA  expr_logica_aritmetica  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :} 
| WHILE error {: System.out.println("Error sintáctico en la definición de un while."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};

for_expr ::= FOR PARENTESIS_APERTURA  inicializacion  COMMA  expr_logica_aritmetica  COMMA  op_simple  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}   bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}
| FOR error {: System.out.println("Error sintáctico en la definición de un for."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};





bloque ::= if_expr | while_expr | for_expr | switch_expr | simple_expr END_EXPR; 
bloques ::= bloque bloques | error {: System.out.println("Error dentro de bloque, verificar definición."); RESULT = "Error"; :} | ; 




nombrefuncion ::= MAIN {: RESULT = "_verano_"; :} | IDENTIFICADOR:nombreFunc {: RESULT = nombreFunc; :};




funciones ::= funcion | funcion funciones | error {: System.out.println("Error fatal en la definición de una función, deteniendo parseo."); :}; 




funcion ::= tipo:t nombrefuncion:funcName PARENTESIS_APERTURA {: symbolTable.addScope(); symbolTable.setActualFunction(funcName.toString()); :}  parametros_decl:params  PARENTESIS_CIERRE 
{:
    if(!symbolTable.addGlobalSymbol(funcName.toString(), t + ":" + funcName + ":" + params)) {
        reportSemanticError("Error semántico durante declaración, ya existe una función con el mismo nombre.\n");
    }
:}  
APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE 
{: 
    symbolTable.printScope(); 
    symbolTable.exitScope();
    symbolTable.setActualFunction(""); 
:} | 
tipo:t nombrefuncion:funcName PARENTESIS_APERTURA {: symbolTable.addScope(); symbolTable.setActualFunction(funcName.toString()); :}  error  PARENTESIS_CIERRE 
{:
    if(!symbolTable.addGlobalSymbol(funcName.toString(), t + ":" + funcName + ":error")) {
        reportSemanticError("Error semántico durante declaración, ya existe una función con el mismo nombre.\n");
    }
:} 
APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE 
{: 
    System.out.println("Error en la definición de parámetros de una función."); 
    symbolTable.printScope(); 
    symbolTable.exitScope(); 
    symbolTable.setActualFunction("");
:};




programa ::=  funciones {: symbolTable.printGlobalScope(); :} | {: RESULT = ""; :};


/* ejecutar desde Compilador */
/* java -cp lib/java-cup-11b.jar java_cup.Main -parser Parser -symbols sym -destdir src src/parser.cup */
