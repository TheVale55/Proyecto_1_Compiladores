//import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java_cup.runtime.Symbol;


parser code {: 
    private Lexer scanner;
    private SymbolTable symbolTable;
    private String currentHash;
    private BufferedWriter outputFile;



    public Parser(Lexer scanner) {
        this.scanner = scanner;
        this.symbolTable = new SymbolTable();
        this.currentHash = "";
    }




    public void createWriter(String root) throws IOException {
        outputFile = new BufferedWriter(new FileWriter(root));
    }


    public void reportSyntaxError(int line, int column) throws IOException {
        if(outputFile != null) {
            outputFile.write("Error sintáctico recuperado en línea " + line + ", columna " + column + ".\n");
            outputFile.flush();
        }
    }

    public void closeWriter() throws IOException {
        if(outputFile != null) {
            outputFile.close();
        }
    }


    @Override
    public void syntax_error(Symbol current) {
        try {
          reportSyntaxError(current.left, current.right);
          //System.out.println("Error sintáctico, línea: " + current.left + ", columna: " + current.right);
        } catch (IOException e) {
          e.printStackTrace();
        }
    }

:};

//init with {: scanner.init(); :};

scan with {: return scanner.next_token(); :};

//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;

//bloques de código
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;

//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;

//asignacion =
terminal ASIGNACION;

//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 

//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;

//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;

//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;

//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;

//funciones de leer
terminal PRINT, READ;

//identificadores
terminal IDENTIFICADOR;

//final de expresion y Main
terminal END_EXPR, MAIN;

non terminal tipo, literal, op_aritmeticas, dato_general, sec_oper, sec_var, imprimir, leer_var, inicializacion, 
actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion_operacion, op_logica, expr_logica_aritmetica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, funciones, funcion, programa, llamada_funcion, parametros_llamada, expr_unaria;


//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;
precedence right INCREMENTO, DECREMENTO;

start with programa;




//Reglas


parametro_decl ::= tipo:t IDENTIFICADOR:idVar COMMA parametro_decl:param {: symbolTable.addSymbol(idVar.toString(), t + ":" + idVar); RESULT = t + ":" + idVar + ":" + param; :}
| tipo:t IDENTIFICADOR:idVar {: symbolTable.addSymbol(idVar.toString(), t + ":" + idVar); RESULT = t + ":" + idVar; :};




parametros_decl ::= parametro_decl:params {: RESULT = params; :} | {: RESULT = ""; :};



sec_oper ::= dato_general:dato COMMA sec_oper:seq {: RESULT = dato + ":" + seq; :} | dato_general:dato {: RESULT = dato; :};



parametros_llamada ::= sec_oper:seq {: RESULT = seq; :} | {: RESULT = ""; :} ;





llamada_funcion ::= nombrefuncion:f PARENTESIS_APERTURA parametros_llamada:params PARENTESIS_CIERRE 
{:
    System.out.println("Llamada a función: " + f.toString() + ", argumentos: " + params.toString());
    RESULT = f + ":" + params.toString();
:};





tipo ::= INTEGER {: RESULT = "int"; :}
        | FLOAT {: RESULT = "float"; :}
        | BOOL {: RESULT = "bool"; :}
        | CHAR {: RESULT = "char"; :}
        | STRING {: RESULT = "string"; :};



literal ::= INT_LITERAL:intVar {: RESULT = intVar.toString(); :}
          | STRING_LITERAL:strVar {: RESULT = strVar.toString(); :}
          | FLOAT_LITERAL:floatVar {: RESULT = floatVar.toString(); :}
          | CHAR_LITERAL:charVar {:  RESULT = charVar.toString(); :}
          | BOOL_LITERAL:boolVar {:  RESULT = boolVar.toString(); :};





op_aritmeticas ::= SUMA {: RESULT = "+"; :} | RESTA {: RESULT = "-"; :} | MULTIPLICACION {: RESULT = "*"; :} | DIVISION {:  RESULT = "/"; :} | MODULO {: RESULT = "%"; :} | POTENCIA {:  RESULT = "^"; :};



dato_general ::= IDENTIFICADOR:idVar {: RESULT = idVar.toString(); :} | literal:lit {: RESULT = lit.toString(); :} | llamada_funcion:func {: RESULT = func; :};



op_unaria ::= INCREMENTO {:  RESULT = "++"; :} | DECREMENTO {:  RESULT = "--"; :};



expr_unaria ::= IDENTIFICADOR:idVar op_unaria:op {:  RESULT = idVar.toString() + op; :};



sec_var ::= IDENTIFICADOR COMMA sec_var | IDENTIFICADOR;



imprimir ::= PRINT PARENTESIS_APERTURA sec_oper PARENTESIS_CIERRE; 
leer_var ::= READ PARENTESIS_APERTURA sec_var PARENTESIS_CIERRE; 





actualizacion ::= ASIGNACION {: RESULT = "="; :} | op_aritmeticas:arit_op ASIGNACION {: RESULT = arit_op + "="; :};
asignacion_arreglo ::= IDENTIFICADOR:idVar ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE 
{:
    System.out.println("Asignación arreglo: " + idVar + ", valores: " + seq);
    RESULT = idVar + ":" + seq;

:};




asignacion_indice ::= IDENTIFICADOR:idVar CORCHETE_APERTURA dato_general:dato CORCHETE_CIERRE actualizacion:act expr_logica_aritmetica:e 
{: System.out.println("Asignación por índice: " + idVar + "[" + dato + "] " + act + " " + e.toString());
    RESULT = idVar + ":" + dato + ":" + act + ":" + e.toString();
:};




asignacion_variable ::= IDENTIFICADOR:idVar  actualizacion:act  expr_logica_aritmetica:e 
{:  System.out.println("Asignación de variable: " + idVar + " " + act + " " + e);
    RESULT = idVar + ":" + act + ":" + e.toString();
:};



asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;





declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE {: RESULT = seq.toString(); :} | {: RESULT = ""; :}; 
declaracion ::= tipo:t IDENTIFICADOR:idVar {: System.out.println("Declaración de variable: " + t + " " + idVar); RESULT = t + ":" + idVar; symbolTable.addSymbol(idVar.toString(), t + ":" + idVar); :}
              | tipo:t IDENTIFICADOR:idVar ASIGNACION expr_logica_aritmetica:e {: System.out.println("Declaración de variable con asignación: " + t + " " + idVar + " = " + e); RESULT = t + ":" + idVar + ":" + e; symbolTable.addSymbol(idVar.toString(), t + ":" + idVar); :}
              | tipo:t IDENTIFICADOR:idVar CORCHETE_APERTURA dato_general:dato CORCHETE_CIERRE declaracion_arreglo_op:arr_decl {: String text = t + ":" + idVar + ":" + dato + ":" + arr_decl; System.out.println("Declaración arreglo: " + t + " " + idVar + "[" + dato + "] = " + arr_decl);  RESULT = text; symbolTable.addSymbol(idVar.toString(), t + ":" + idVar);  :};





else_expr ::= ELSE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques CIERRE_DE_BLOQUE; 
else_op ::= else_expr | {: RESULT = ""; :};





relacion ::= MENOR {: RESULT = "<"; :} | MENOR_IGUAL {: RESULT = "<="; :} | MAYOR {: RESULT = ">"; :} | MAYOR_IGUAL {: RESULT = ">="; :} | IGUALDAD {: RESULT = "=="; :} | DIFERENTE {: RESULT = "!="; :};





comparacion_operacion ::= expr_logica_aritmetica:e1  relacion:rel  expr_logica_aritmetica:e2 {: RESULT = e1.toString() + ":" + rel + ":" + e2.toString(); :} 
| expr_logica_aritmetica:e1  op_aritmeticas:op  expr_logica_aritmetica:e2 {: RESULT = e1 + ":" + op + ":" + e2; :}
| dato_general:dato {: RESULT = dato; :}
| expr_unaria:op {: RESULT = op; :}; 






op_logica ::= CONJUNCION {: RESULT = "and"; :} | DISYUNCION {: RESULT = "or"; :};





expr_logica_aritmetica ::= NEGACION expr_logica_aritmetica:e {: RESULT = "not " + e.toString(); :} 
| expr_logica_aritmetica:e1  op_logica:op  expr_logica_aritmetica:e2 {: RESULT = e1.toString() + ":" + op + ":" + e2.toString();  :} 
| comparacion_operacion:cmp {: RESULT = cmp; :} 
| PARENTESIS_APERTURA expr_logica_aritmetica:e PARENTESIS_CIERRE {: RESULT = "(" + e.toString() + ")"; :}; 




if_expr ::= IF PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}   bloques   CIERRE_DE_BLOQUE else_op
| IF error {: System.out.println("Error sintáctico en la definición de un if."); :} APERTURA_DE_BLOQUE bloques CIERRE_DE_BLOQUE else_op;





cases ::= CASE literal DOS_PUNTOS bloques cases | DEFAULT DOS_PUNTOS bloques;
switch_expr ::= SWITCH PARENTESIS_APERTURA dato_general PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  cases CIERRE_DE_BLOQUE 
| SWITCH error {: System.out.println("Error sintáctico en la definición de una switch."); :} APERTURA_DE_BLOQUE   cases   CIERRE_DE_BLOQUE;





finfuncion ::= RETURN dato_general:dato {: System.out.println("Retorno del valor: " + dato.toString()); :} | RETURN {: System.out.println("Sin valor de retorno"); :};
op_simple ::= expr_unaria | asignacion_variable; 
simple_expr ::= expr_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | llamada_funcion | finfuncion | error {: RESULT = "Error"; System.out.println("Error sintáctico en la definición de una expresión simple."); :};
inicializacion ::= asignacion_variable:asign {: RESULT = asign; :} | IDENTIFICADOR:i {: RESULT = i; :};





while_expr ::= WHILE PARENTESIS_APERTURA  expr_logica_aritmetica  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE 
| WHILE error {: System.out.println("Error sintáctico en la definición de un while."); :} APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE;

for_expr ::= FOR PARENTESIS_APERTURA  inicializacion  COMMA  expr_logica_aritmetica  COMMA  op_simple  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}   bloques  CIERRE_DE_BLOQUE 
| FOR error {: System.out.println("Error sintáctico en la definición de un for."); :} APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;





bloque ::= if_expr | while_expr | for_expr | switch_expr | simple_expr END_EXPR; 
bloques ::= bloque bloques | error {: System.out.println("Error dentro de bloque, verificar definición."); RESULT = "Error"; :} | ; 




nombrefuncion ::= MAIN {: 
                    RESULT = "_verano_"; 
                    System.out.println("Scope cambiado a: _verano_");
                    symbolTable.addScope();
                :}
                 | IDENTIFICADOR:nombreFunc {: 
                    RESULT = nombreFunc;
                    System.out.println("Scope cambiado a: " + nombreFunc);
                    symbolTable.addScope();
                :};



funciones ::= funcion | funcion funciones | error {: System.out.println("Error fatal en la definición de una función, deteniendo parseo."); :};                                  
funcion ::= tipo:t nombrefuncion:funcName PARENTESIS_APERTURA   parametros_decl:params   PARENTESIS_CIERRE    {: System.out.println("Declaración de función: " + funcName + ", parámetros: " + "(" + params + "), " + "tipo: " + t.toString()); symbolTable.addSymbol(funcName, t + ":" + funcName + ":" + params); :}   APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE
| tipo nombrefuncion PARENTESIS_APERTURA  error  PARENTESIS_CIERRE  {: System.out.println("Error en la definición de parámetros de una función."); :}  APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE;




programa ::= funciones {: System.out.println("Información de la tabla de símbolos no disponible aún"); :} | {: RESULT = ""; :};


/* ejecutar desde Compilador */
/* java -cp lib/java-cup-11b.jar java_cup.Main -parser Parser -symbols sym -destdir src src/parser.cup */
