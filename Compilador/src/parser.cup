import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java_cup.runtime.Symbol;



parser code {: 
    private Lexer scanner;
    private SymbolTable symbolTable;
    private BufferedWriter syntaxFile;
    private BufferedWriter semanticFile;


    @SuppressWarnings("deprecation")
    public Parser(Lexer scanner) {
        this.scanner = scanner;
        this.symbolTable = new SymbolTable();
    }

    public void createSemanticWriter(String root) throws IOException {
        semanticFile = new BufferedWriter(new FileWriter(root));
    }


    public void createSyntaxWriter(String root) throws IOException {
        syntaxFile = new BufferedWriter(new FileWriter(root));
    }


    public void reportSyntaxError(int line, int column) throws IOException {
        if(syntaxFile != null) {
            syntaxFile.write("Error sintáctico recuperado en línea " + line + ", columna " + column + ".\n");
            syntaxFile.flush();
        }
    }


    public void reportSemanticError(String text) throws IOException {
        if(semanticFile != null) {
            semanticFile.write(text);
            semanticFile.flush();
        }
    }


    public void closeSyntaxWriter() throws IOException {
        if(syntaxFile != null) {
            syntaxFile.close();
        }
    }


    public void closeSemanticWriter() throws IOException {
        if(semanticFile != null) {
            semanticFile.close();
        }
    }


    @Override
    public void syntax_error(Symbol current) {
        try {
          reportSyntaxError(current.left, current.right);
        } catch (IOException e) {
          e.printStackTrace();
        }
    }

:};



scan with {: return scanner.next_token(); :};

//tipos de datos
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL, FLOAT_LITERAL, CHAR_LITERAL;

//bloques de código
terminal APERTURA_DE_BLOQUE, CIERRE_DE_BLOQUE;

//corchetes
terminal CORCHETE_APERTURA, CORCHETE_CIERRE;

//asignacion =
terminal ASIGNACION;

//Parentesis
terminal PARENTESIS_APERTURA, PARENTESIS_CIERRE; 

//expresiones aritmeticas
terminal SUMA, RESTA, MULTIPLICACION, MODULO, POTENCIA, DIVISION;

//expresiones aritmeticas unarias
terminal INCREMENTO, DECREMENTO;

//expresiones relacionales (igualdad es ==)
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;

//expresiones logicas
terminal CONJUNCION, DISYUNCION, NEGACION;

//estructuras de control
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, COMMA;

//funciones de leer
terminal PRINT, READ;

//identificadores
terminal IDENTIFICADOR;

//final de expresion y Main
terminal END_EXPR, MAIN;

non terminal tipo, literal, op_aritmeticas, dato_general, sec_oper, sec_var, imprimir, leer_var, inicializacion, 
actualizacion, asignacion_arreglo, asignacion_indice, asignacion_variable, asignacion_compuesta, 
declaracion_arreglo_op, declaracion, op_unaria, finfuncion, nombrefuncion, parametro_decl, parametros_decl, else_expr, else_op, relacion, 
comparacion_operacion, op_logica, expr_logica_aritmetica, if_expr, cases, switch_expr, op_simple, simple_expr, while_expr, for_expr, 
bloque, bloques, funciones, funcion, programa, llamada_funcion, parametros_llamada, expr_unaria, acceso_arreglo, default_op;


//precedencias
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUALDAD, DIFERENTE;
precedence right INCREMENTO, DECREMENTO;

start with programa;



//Reglas gramáticales


// Regla para la declaración de parámetros en una función.
parametro_decl ::= tipo:t IDENTIFICADOR:idVar COMMA parametro_decl:param 
{: 
    // Hacemos casting explícito a Symbol para poder acceder a left, right y value
    Symbol idVarSymbol = (Symbol) idVar;
    Symbol paramSymbol = (Symbol) param;
    Symbol tipoSymbol = (Symbol) t;

    // Verificamos si ya existe en la tabla de símbolos
    if (!symbolTable.addSymbol(idVarSymbol.value.toString(), tipoSymbol.value.toString())) {
        reportSemanticError("Error semántico en línea " + idVarSymbol.left + ", columna " + idVarSymbol.right +
                            ": Parámetro '" + idVarSymbol.value.toString() + "' ya fue declarado.\n");
    }

    // Creamos un nuevo símbolo para el resultado
    RESULT = parser.getSymbolFactory().newSymbol("parametro_decl", 0, idVarSymbol, 
                                                 tipoSymbol.value.toString() + ":" + idVarSymbol.value.toString() + ", " + paramSymbol.value.toString());
:}
| tipo:t IDENTIFICADOR:idVar 
{: 
    // Hacemos casting explícito a Symbol
    Symbol idVarSymbol = (Symbol) idVar;
    Symbol tipoSymbol = (Symbol) t;

    // Verificamos si ya existe en la tabla de símbolos
    if (!symbolTable.addSymbol(idVarSymbol.value.toString(), tipoSymbol.value.toString())) {
        reportSemanticError("Error semántico en línea " + idVarSymbol.left + ", columna " + idVarSymbol.right +
                            ": Parámetro '" + idVarSymbol.value.toString() + "' ya fue declarado.\n");
    }

    // Creamos un nuevo símbolo para el resultado
    RESULT = parser.getSymbolFactory().newSymbol("parametro_decl", 0, idVarSymbol, 
                                                 tipoSymbol.value.toString() + ":" + idVarSymbol.value.toString());
:};


// Regla para definir el conjunto completo de parámetros en una función.
parametros_decl ::= parametro_decl:params 
{: 
    Symbol paramsSymbol = (Symbol) params;
    RESULT = parser.getSymbolFactory().newSymbol("parametros_decl", 0, paramsSymbol, paramsSymbol.value.toString()); 
:} 
| 
{: RESULT = parser.getSymbolFactory().newSymbol("parametros_decl", 0, (Symbol) null, (Symbol) null);:};

// Regla para las operaciones en las llamadas a funciones.
sec_oper ::= expr_logica_aritmetica:dato COMMA sec_oper:seq 
{: 
    Symbol datoSymbol = (Symbol) dato;
    Symbol seqSymbol = (Symbol) seq;
    RESULT = parser.getSymbolFactory().newSymbol("sec_oper", 0, datoSymbol, datoSymbol.value.toString() + ":" + seqSymbol.value.toString()); 
:} 
| expr_logica_aritmetica:dato 
{: 
    Symbol datoSymbol = (Symbol) dato;
    RESULT = parser.getSymbolFactory().newSymbol("sec_oper", 0, datoSymbol, datoSymbol.value.toString()); 
:};

// Definición de los parámetros en las llamadas a funciones.
parametros_llamada ::= sec_oper:seq 
{: 
    Symbol seqSymbol = (Symbol) seq;
    RESULT = parser.getSymbolFactory().newSymbol("parametros_llamada", 0, seqSymbol, seqSymbol.value.toString()); 
:} 
| 
{: RESULT = parser.getSymbolFactory().newSymbol("parametros_llamada", 0, null, null); :};

// Regla para las llamadas a funciones.
llamada_funcion ::= nombrefuncion:f PARENTESIS_APERTURA parametros_llamada:params PARENTESIS_CIERRE 
{: 
    Symbol funcSymbol = (Symbol) f;
    Symbol paramsSymbol = (Symbol) params;
    String funcName = funcSymbol.value.toString();
    
    // Recupera el tipo de la función de la tabla de símbolos.
    String functionType = symbolTable.getType(funcName);
    
    // Verifica que la llamada sea válida en términos de parámetros y existencia.
    if (!symbolTable.verifyFunctionCall(funcName, paramsSymbol.value.toString())) {
        reportSemanticError("Error en la llamada a la función '" + funcName + 
                            "' con parámetros '" + paramsSymbol.value.toString() + "'.\n");
    }
    
    // Devolvemos un símbolo con el tipo de retorno de la función.
    RESULT = parser.getSymbolFactory().newSymbol("llamada_funcion", 0, funcSymbol, functionType);
:};

// Definición de tipos básicos.
tipo ::= INTEGER:i 
        {: 
            Symbol intSymbol = (Symbol) i;
            RESULT = parser.getSymbolFactory().newSymbol("tipo", 0, intSymbol, "int"); 
        :}
        | FLOAT:f 
        {: 
            Symbol floatSymbol = (Symbol) f;
            RESULT = parser.getSymbolFactory().newSymbol("tipo", 0, floatSymbol, "float"); 
        :}
        | BOOL:b 
        {: 
            Symbol boolSymbol = (Symbol) b;
            RESULT = parser.getSymbolFactory().newSymbol("tipo", 0, boolSymbol, "bool"); 
        :}
        | CHAR:c 
        {: 
            Symbol charSymbol = (Symbol) c;
            RESULT = parser.getSymbolFactory().newSymbol("tipo", 0, charSymbol, "char"); 
        :}
        | STRING:s 
        {: 
            Symbol stringSymbol = (Symbol) s;
            RESULT = parser.getSymbolFactory().newSymbol("tipo", 0, stringSymbol, "string"); 
        :};


// Reglas para literales de diferentes tipos.
literal ::= INT_LITERAL:intVar 
        {: 
            Symbol intSymbol = (Symbol) intVar;
            RESULT = parser.getSymbolFactory().newSymbol("literal", 0, intSymbol, "int"); 
        :}
        | STRING_LITERAL:strVar 
        {: 
            Symbol strSymbol = (Symbol) strVar;
            RESULT = parser.getSymbolFactory().newSymbol("literal", 0, strSymbol, "string"); 
        :}
        | FLOAT_LITERAL:floatVar 
        {: 
            Symbol floatSymbol = (Symbol) floatVar;
            RESULT = parser.getSymbolFactory().newSymbol("literal", 0, floatSymbol, "float"); 
        :}
        | CHAR_LITERAL:charVar 
        {:  
            Symbol charSymbol = (Symbol) charVar;
            RESULT = parser.getSymbolFactory().newSymbol("literal", 0, charSymbol, "char"); 
        :}
        | BOOL_LITERAL:boolVar 
        {:  
            Symbol boolSymbol = (Symbol) boolVar;
            RESULT = parser.getSymbolFactory().newSymbol("literal", 0, boolSymbol, "bool"); 
        :};


// Operadores aritméticos básicos.
op_aritmeticas ::= SUMA:s 
        {: 
            Symbol sSymbol = (Symbol) s;
            RESULT = parser.getSymbolFactory().newSymbol("op_aritmeticas", 0, sSymbol, "+"); 
        :} 
        | RESTA:r 
        {: 
            Symbol rSymbol = (Symbol) r;
            RESULT = parser.getSymbolFactory().newSymbol("op_aritmeticas", 0, rSymbol, "-"); 
        :} 
        | MULTIPLICACION:m 
        {: 
            Symbol mSymbol = (Symbol) m;
            RESULT = parser.getSymbolFactory().newSymbol("op_aritmeticas", 0, mSymbol, "*"); 
        :} 
        | DIVISION:d 
        {:  
            Symbol dSymbol = (Symbol) d;
            RESULT = parser.getSymbolFactory().newSymbol("op_aritmeticas", 0, dSymbol, "/"); 
        :} 
        | MODULO:m 
        {: 
            Symbol mSymbol = (Symbol) m;
            RESULT = parser.getSymbolFactory().newSymbol("op_aritmeticas", 0, mSymbol, "%"); 
        :} 
        | POTENCIA:p 
        {:  
            Symbol pSymbol = (Symbol) p;
            RESULT = parser.getSymbolFactory().newSymbol("op_aritmeticas", 0, pSymbol, "^"); 
:};


// Regla para datos generales: identificadores, literales, funciones o arreglos.
dato_general ::= IDENTIFICADOR:idVar 
        {: 
            Symbol idSymbol = (Symbol) idVar;
            RESULT = parser.getSymbolFactory().newSymbol("dato_general", 0, idSymbol, idSymbol.value.toString());  
        :} 
        | literal:lit 
        {: 
            Symbol litSymbol = (Symbol) lit;
            RESULT = parser.getSymbolFactory().newSymbol("dato_general", 0, litSymbol, litSymbol.value.toString());  
        :} 
        | llamada_funcion:func 
        {: 
            Symbol funcSymbol = (Symbol) func;
            RESULT = parser.getSymbolFactory().newSymbol("dato_general", 0, funcSymbol, funcSymbol.value.toString());  
        :} 
        | acceso_arreglo:arrName 
        {: 
            Symbol arrSymbol = (Symbol) arrName;
            RESULT = parser.getSymbolFactory().newSymbol("dato_general", 0, arrSymbol, arrSymbol.value.toString());  
        :};

// Operadores unarios como incremento y decremento.
op_unaria ::= INCREMENTO:i {:  RESULT = parser.getSymbolFactory().newSymbol("op_unaria", 0, (Symbol) i, "++"); :} 
            | DECREMENTO:d {:  RESULT = parser.getSymbolFactory().newSymbol("op_unaria", 0, (Symbol) d, "--"); :};

// Expresiones unarias, aplicadas sobre identificadores.
expr_unaria ::= IDENTIFICADOR:idVar op_unaria:op 
{:  
    Symbol idSymbol = (Symbol) idVar;
    RESULT = idSymbol; 
    if(!symbolTable.isInLocalScope(idSymbol.value.toString())) {
        reportSemanticError("Error semántico, identificador fuera del scope.\n");
    }
:};

// Secuencia de variables separadas por comas.
sec_var ::= IDENTIFICADOR:idVar COMMA sec_var:seq 
{: 
    Symbol idSymbol = (Symbol) idVar;
    Symbol seqSymbol = (Symbol) seq;
    RESULT = parser.getSymbolFactory().newSymbol("sec_var", 0, idSymbol, idSymbol.value.toString() + "," + seqSymbol.value.toString()); 
:} 
| IDENTIFICADOR:idVar 
{: 
    Symbol idSymbol = (Symbol) idVar;
    RESULT = parser.getSymbolFactory().newSymbol("sec_var", 0, idSymbol, idSymbol.value.toString()); 
:};

// Simplificación para imprimir un único valor.
imprimir ::= PRINT PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE;

// Leer un valor desde la entrada del usuario.
leer_var ::= READ PARENTESIS_APERTURA expr_logica_aritmetica PARENTESIS_CIERRE;

// Leer un valor desde la entrada del usuario.
acceso_arreglo ::= IDENTIFICADOR:idVar CORCHETE_APERTURA expr_logica_aritmetica:e CORCHETE_CIERRE 
{: 
    Symbol exprSymbol = (Symbol) e;
    Symbol idSymbol = (Symbol) idVar;
    if(!symbolTable.isIndexInteger(exprSymbol.value.toString())) {
        reportSemanticError("Error semántico, el tipo de dato de un índice debe ser entero.\n");
    }
    RESULT = parser.getSymbolFactory().newSymbol("acceso_arreglo", 0, idSymbol, idSymbol.value.toString()); 
:};

// Regla para actualización de valores en asignaciones.
actualizacion ::= ASIGNACION:a 
{: 
    Symbol aSymbol = (Symbol) a;
    RESULT = parser.getSymbolFactory().newSymbol("actualizacion", 0, aSymbol, "="); 
:} 
| op_aritmeticas:arit_op ASIGNACION:a 
{: 
    Symbol aritSymbol = (Symbol) arit_op;
    Symbol aSymbol = (Symbol) a;
    RESULT = parser.getSymbolFactory().newSymbol("actualizacion", 0, aSymbol, aritSymbol.value.toString() + "="); 
:};

// Regla para actualización de valores en asignaciones.
asignacion_arreglo ::= IDENTIFICADOR:idVar ASIGNACION:a APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE 
{: 
    Symbol idSymbol = (Symbol) idVar;
    Symbol seqSymbol = (Symbol) seq;
    if(!symbolTable.verifyArrayDeclaration(symbolTable.getType(idSymbol.value.toString()), seqSymbol.value.toString())) { 
        reportSemanticError("Error en el tipo de datos de una asignación o hay una variable que está fuera del scope.\n");
    }
    RESULT = parser.getSymbolFactory().newSymbol("asignacion_arreglo", 0, idSymbol, idSymbol.value.toString() + ":" + seqSymbol.value.toString());
:};

// Regla para actualización de valores en asignaciones.
asignacion_indice ::= acceso_arreglo:arr actualizacion:act expr_logica_aritmetica:e 
{: 
    Symbol arrSymbol = (Symbol) arr;
    Symbol exprSymbol = (Symbol) e;
    if(!symbolTable.verifyType(symbolTable.getType(arrSymbol.value.toString()), exprSymbol.value.toString())) {
        reportSemanticError("Error en el tipo de datos de una asignación o hay una variable que está fuera del scope.\n");
    }
    RESULT = arrSymbol;                         
:};

// Asignación de valores a una variable.
asignacion_variable ::= IDENTIFICADOR:idVar actualizacion:act expr_logica_aritmetica:e 
{: 
    Symbol idSymbol = (Symbol) idVar;
    Symbol actSymbol = (Symbol) act;
    Symbol exprSymbol = (Symbol) e;
    if(!symbolTable.verifyType(symbolTable.getType(idSymbol.value.toString()), exprSymbol.value.toString())) {
        reportSemanticError("Error en el tipo de datos de una asignación o hay una variable que está fuera del scope.\n");
    }
    RESULT = parser.getSymbolFactory().newSymbol("asignacion_variable", 0, idSymbol, idSymbol.value.toString() + ":" + actSymbol.value.toString() + ":" + exprSymbol.value.toString()); 
:};
// Regla general para asignaciones: puede ser a una variable, arreglo o un índice de arreglo.
asignacion_compuesta ::= asignacion_variable | asignacion_arreglo | asignacion_indice;

// Declaración opcional de un arreglo, con o sin asignación de valores iniciales.
declaracion_arreglo_op ::= ASIGNACION APERTURA_DE_BLOQUE sec_oper:seq CIERRE_DE_BLOQUE {: Symbol seqSymbol = (Symbol) seq; RESULT = parser.getSymbolFactory().newSymbol("declaracion_arreglo_op", 0, seqSymbol, seqSymbol.value.toString());:}
                        | {: RESULT = parser.getSymbolFactory().newSymbol("declaracion_arreglo_op", 0, null, null); :};



// Declaración de variables, con validaciones semánticas.
declaracion ::= tipo:t IDENTIFICADOR:idVar 
              {: 
                Symbol tSymbol = (Symbol) t;
                Symbol idVarSymbol = (Symbol) idVar;
                RESULT = parser.getSymbolFactory().newSymbol("declaracion", 0, idVarSymbol, tSymbol.value.toString()); 
                if(!symbolTable.addSymbol(idVarSymbol.value.toString(), tSymbol.value.toString() + ":" + idVarSymbol.value.toString())) {
                    reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope.\n");
                } 
              :}
              | tipo:t IDENTIFICADOR:idVar ASIGNACION expr_logica_aritmetica:e 
              {:     
                    Symbol tSymbol = (Symbol) t;
                    Symbol idVarSymbol = (Symbol) idVar;
                    Symbol exprSymbol = (Symbol) e;
                    RESULT = parser.getSymbolFactory().newSymbol("declaracion", 0, idVarSymbol, tSymbol.value.toString()); 
                    if(!symbolTable.addSymbol(idVarSymbol.value.toString(), tSymbol.value.toString() + ":" + idVarSymbol.value.toString())) {
                        reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope.\n");
                    } 
                    if(!symbolTable.verifyType(tSymbol.value.toString(), exprSymbol.value.toString())) {
                        reportSemanticError("Error en el tipo de datos en la asignación de una declaración o existencia de una variable fuera del scope.\n");
                    }
              :}
              | tipo:t acceso_arreglo:arrName declaracion_arreglo_op:arr_decl 
              {:    
                    Symbol tSymbol = (Symbol) t;
                    Symbol arrSymbol = (Symbol) arrName;
                    Symbol arrDeclSymbol = (Symbol) arr_decl;
                    RESULT = parser.getSymbolFactory().newSymbol("declaracion", 0, arrSymbol, tSymbol.value.toString()); 
                    if(!symbolTable.addSymbol(arrSymbol.value.toString(), tSymbol.value.toString() + ":" + arrSymbol.value.toString())) {
                        reportSemanticError("Error semántico en una declaración. Ya existe una variable con el mismo nombre dentro del scope.\n");
                    }  
                    if(!symbolTable.verifyType(tSymbol.value.toString(), arrDeclSymbol.value.toString())) {
                        reportSemanticError("Error en el tipo de datos en la asignación de una declaración o existencia de una variable fuera del scope.\n");
                    }
              :};



// Definición de una cláusula else opcional.
else_expr ::= ELSE APERTURA_DE_BLOQUE {: symbolTable.addScope(); :}  bloques CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :}; 

// Definición del operador else como opcional.
else_op ::= else_expr | {: RESULT = parser.getSymbolFactory().newSymbol("else_op", 0, null, null); :};

// Relación entre dos expresiones (comparaciones).
relacion ::= MENOR:m {: RESULT = parser.getSymbolFactory().newSymbol("relacion", 0, m); :} 
            | MENOR_IGUAL:mi {: RESULT = parser.getSymbolFactory().newSymbol("relacion", 0, mi); :} 
            | MAYOR:ma {: RESULT = parser.getSymbolFactory().newSymbol("relacion", 0, ma); :} 
            | MAYOR_IGUAL:mg {: RESULT = parser.getSymbolFactory().newSymbol("relacion", 0, mg); :} 
            | IGUALDAD:i {: RESULT = parser.getSymbolFactory().newSymbol("relacion", 0, i); :} 
            | DIFERENTE:d {: RESULT = parser.getSymbolFactory().newSymbol("relacion", 0, d); :};

// Comparaciones y operaciones aritméticas.
comparacion_operacion ::= expr_logica_aritmetica:e1  relacion:rel  expr_logica_aritmetica:e2 
{: 
    Symbol expr1Symbol = (Symbol) e1;
    Symbol relSymbol = (Symbol) rel;
    Symbol expr2Symbol = (Symbol) e2;
    if(!symbolTable.validateOperation(expr1Symbol.value.toString(), relSymbol.value.toString(), expr2Symbol.value.toString())) {
        reportSemanticError("Error semántico al operar o comparar tipos que no son compatibles o están fuera del scope.\n");
    }
    RESULT = expr1Symbol; 
:} | expr_logica_aritmetica:e1  op_aritmeticas:op  expr_logica_aritmetica:e2 
{: 
    Symbol expr1Symbol = (Symbol) e1;
    Symbol opSymbol = (Symbol) op;
    Symbol expr2Symbol = (Symbol) e2;
    if(!symbolTable.validateOperation(expr1Symbol.value.toString(), opSymbol.value.toString(), expr2Symbol.value.toString())) {
        reportSemanticError("Error semántico al operar o comparar tipos que no son compatibles o están fuera del scope.\n");
    }
    RESULT = expr1Symbol; 
:} 
| dato_general:dato 
{: 
    Symbol datoSymbol = (Symbol) dato;
    if(!symbolTable.isDataType(datoSymbol.value.toString()) && !symbolTable.isInLocalScope(datoSymbol.value.toString())) {
        reportSemanticError("Error semántico, variable fuera del scope.\n");
    }
    RESULT = datoSymbol;
:} | expr_unaria:op {: RESULT = op; :}; 

// Operadores lógicos  and y or  
op_logica ::= CONJUNCION:c {: RESULT = parser.getSymbolFactory().newSymbol("op_logica", 0, c); :} 
            | DISYUNCION:d {: RESULT = parser.getSymbolFactory().newSymbol("op_logica", 0, d); :};

// Expresiones lógicas y aritméticas con validaciones.
expr_logica_aritmetica ::= NEGACION expr_logica_aritmetica:e 
                        {: 
                            Symbol exprSymbol = (Symbol) e;
                            RESULT = parser.getSymbolFactory().newSymbol("expr_logica_aritmetica", 0, exprSymbol, "!" + exprSymbol.value.toString());
                        :} 
                        | expr_logica_aritmetica:e1  op_logica:op  expr_logica_aritmetica:e2 
                        {: 
                            Symbol e1Symbol = (Symbol) e1;
                            Symbol opSymbol = (Symbol) op;
                            Symbol e2Symbol = (Symbol) e2;
                            RESULT = parser.getSymbolFactory().newSymbol("expr_logica_aritmetica", 0, e1Symbol, e1Symbol.value.toString() + " " + opSymbol.value.toString() + " " + e2Symbol.value.toString());
                        :} 
                        | comparacion_operacion:cmp 
                        {: 
                            Symbol cmpSymbol = (Symbol) cmp;
                            RESULT = parser.getSymbolFactory().newSymbol("expr_logica_aritmetica", 0, cmpSymbol, cmpSymbol.value);
                        :} 
                        | PARENTESIS_APERTURA expr_logica_aritmetica:e PARENTESIS_CIERRE 
                        {: 
                            Symbol eSymbol = (Symbol) e;
                            RESULT = parser.getSymbolFactory().newSymbol("expr_logica_aritmetica", 0, eSymbol, "(" + eSymbol.value.toString() + ")");
                        :};



// Expresiones lógicas y aritméticas con validaciones.
if_expr ::= IF PARENTESIS_APERTURA expr_logica_aritmetica:e PARENTESIS_CIERRE APERTURA_DE_BLOQUE  
            {: symbolTable.addScope(); :}   bloques   CIERRE_DE_BLOQUE  {: symbolTable.printScope(); symbolTable.exitScope(); :}  else_op
            | IF error {: System.out.println("Error sintáctico en la definición de un if."); :} APERTURA_DE_BLOQUE {: symbolTable.addScope(); :} bloques CIERRE_DE_BLOQUE  {: symbolTable.printScope(); symbolTable.exitScope(); :}  else_op;

// Definición de un caso por defecto en una estructura SWITCH.
default_op ::= DEFAULT DOS_PUNTOS bloques | {: RESULT = parser.getSymbolFactory().newSymbol("default_op", 0, null); :};

// Definición de casos en una estructura SWITCH
cases ::= CASE literal DOS_PUNTOS bloques cases 
        | CASE literal DOS_PUNTOS bloques;

// Definición de una estructura SWITCH con casos y un DEFAULT opcional.
switch_expr ::= SWITCH PARENTESIS_APERTURA dato_general PARENTESIS_CIERRE APERTURA_DE_BLOQUE  
                {: symbolTable.addScope(); :}  cases   default_op   CIERRE_DE_BLOQUE 
                {: symbolTable.printScope(); symbolTable.exitScope(); :}
              | SWITCH error {: System.out.println("Error sintáctico en la definición de una switch."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  cases   default_op   CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};



// Definición de la expresión RETURN dentro de funciones, con validación de tipos
finfuncion ::= RETURN expr_logica_aritmetica:dato 
{: 
    Symbol datoSymbol = (Symbol) dato;
    if(!symbolTable.verifyType(symbolTable.getType(datoSymbol.value.toString()), symbolTable.getActualFunction())) {
        reportSemanticError("Error semántico en el tipo de retorno de función.\n");
    } 
:} | RETURN {: reportSemanticError("Error semántico, el valor de retorno no coincide con el tipo de la función.\n"); :};

// Operaciones simples que pueden ser expresiones unarias o asignaciones.
op_simple ::= expr_unaria | asignacion_variable;

// Expresiones simples, como declaraciones, asignaciones, lectura/escritura, o llamadas a funciones.
simple_expr ::= expr_unaria | declaracion | asignacion_compuesta | leer_var | imprimir | BREAK | llamada_funcion | finfuncion 
              | error {: RESULT = parser.getSymbolFactory().newSymbol("simple_expr", 0, null); System.out.println("Error sintáctico en la definición de una expresión simple."); :};

// Inicialización de variables, que puede ser una asignación o declaración.
inicializacion ::= asignacion_variable:asign {: RESULT = asign; :} 
                 | IDENTIFICADOR:i 
                 {: 
                     Symbol iSymbol = (Symbol) i;
                     RESULT = iSymbol;
                     if(!symbolTable.isInLocalScope(iSymbol.value.toString())) {
                         reportSemanticError("Error semántico, identificador fuera del scope.\n");
                     }
                 :} 
                 | tipo asignacion_variable:asign {: RESULT = asign; :};

// Estructura de control WHILE, con validación de bloques y manejo de scopes.
while_expr ::= WHILE PARENTESIS_APERTURA  expr_logica_aritmetica:e  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  
                {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE 
                {: symbolTable.printScope(); symbolTable.exitScope(); :} 
              | WHILE error {: System.out.println("Error sintáctico en la definición de un while."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};

// Estructura de control FOR con inicialización, condición, y actualización.
for_expr ::= FOR PARENTESIS_APERTURA  inicializacion  COMMA  expr_logica_aritmetica:e  COMMA  op_simple  PARENTESIS_CIERRE APERTURA_DE_BLOQUE  
              {: symbolTable.addScope(); :}   bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :} 
            | FOR error {: System.out.println("Error sintáctico en la definición de un for."); :} APERTURA_DE_BLOQUE  {: symbolTable.addScope(); :}  bloques  CIERRE_DE_BLOQUE {: symbolTable.printScope(); symbolTable.exitScope(); :};



// Un único bloque de código puede ser un IF, WHILE, FOR, SWITCH, o una expresión simple.
bloque ::= if_expr | while_expr | for_expr | switch_expr | simple_expr END_EXPR;

// Secuencia de bloques de código (uno tras otro).
bloques ::= bloque bloques | error {: System.out.println("Error dentro de bloque, verificar definición."); RESULT = parser.getSymbolFactory().newSymbol("bloques", 0, null); :} | ;

// Definición de nombres de funciones, incluyendo el nombre especial MAIN.
nombrefuncion ::= MAIN {: RESULT = parser.getSymbolFactory().newSymbol("nombrefuncion", 0, null, "_verano_"); :} 
                | IDENTIFICADOR:nombreFunc {: RESULT = nombreFunc; :};

// Conjunto de funciones en el programa.
funciones ::= funcion | funcion funciones | error {: System.out.println("Error fatal en la definición de una función, deteniendo parseo."); :};

// Definición de una función con su tipo, nombre, parámetros y cuerpo.
funcion ::= tipo:t nombrefuncion:funcName PARENTESIS_APERTURA 
            {: symbolTable.addScope(); symbolTable.setActualFunction(funcName.toString()); :}  parametros_decl:params  PARENTESIS_CIERRE 
            {: 
                Symbol tSymbol = (Symbol) t;
                Symbol funcSymbol = (Symbol) funcName;
                Symbol paramsSymbol = (Symbol) params;
                
                if(!symbolTable.addGlobalSymbol(funcSymbol.value.toString(), tSymbol.value.toString() + ":" + funcSymbol.value.toString() + ":" + paramsSymbol.value.toString())) {
                    reportSemanticError("Error semántico durante declaración, ya existe una función con el mismo nombre.\n");
                }
            :}  
            APERTURA_DE_BLOQUE   bloques  CIERRE_DE_BLOQUE 
            {: 
                symbolTable.printScope(); 
                symbolTable.exitScope();
                symbolTable.setActualFunction(""); 
            :} 
            | 
            tipo:t nombrefuncion:funcName PARENTESIS_APERTURA 
            {: symbolTable.addScope(); symbolTable.setActualFunction(funcName.toString()); :}  error  PARENTESIS_CIERRE 
            {:
                Symbol tSymbol = (Symbol) t;
                Symbol funcSymbol = (Symbol) funcName;
                
                if(!symbolTable.addGlobalSymbol(funcSymbol.value.toString(), tSymbol.value.toString() + ":" + funcSymbol.value.toString() + ":error")) {
                    reportSemanticError("Error semántico durante declaración, ya existe una función con el mismo nombre.\n");
                }
            :} 
            APERTURA_DE_BLOQUE  bloques  CIERRE_DE_BLOQUE 
            {: 
                System.out.println("Error en la definición de parámetros de una función."); 
                symbolTable.printScope(); 
                symbolTable.exitScope(); 
                symbolTable.setActualFunction("");
            :};

// Definición del programa principal, compuesto por funciones
programa ::=  funciones {: symbolTable.printGlobalScope(); :} | {: RESULT = parser.getSymbolFactory().newSymbol("programa", 0, null); :};


/* ejecutar desde Compilador */
/* java -cp lib/java-cup-11b.jar java_cup.Main -parser Parser -symbols sym -destdir src src/parser.cup */
